// Code generated by protoc-gen-gogo. DO NOT EDIT.
// source: api/nb/c1-interface.proto

package nb

import (
	context "context"
	fmt "fmt"
	proto "github.com/gogo/protobuf/proto"
	grpc "google.golang.org/grpc"
	codes "google.golang.org/grpc/codes"
	status "google.golang.org/grpc/status"
	io "io"
	math "math"
	math_bits "math/bits"
)

// Reference imports to suppress errors if they are not otherwise used.
var _ = proto.Marshal
var _ = fmt.Errorf
var _ = math.Inf

// This is a compile-time assertion to ensure that this generated file
// is compatible with the proto package it is being compiled against.
// A compilation error at this line likely means your copy of the
// proto package needs to be updated.
const _ = proto.GoGoProtoPackageIsVersion3 // please upgrade the proto package

// Enumerated Power offset - It is defined in E2 interface
type StationPowerOffset int32

const (
	StationPowerOffset_PA_DB_MINUS6      StationPowerOffset = 0
	StationPowerOffset_PA_DB_MINUX4DOT77 StationPowerOffset = 1
	StationPowerOffset_PA_DB_MINUS3      StationPowerOffset = 2
	StationPowerOffset_PA_DB_MINUS1DOT77 StationPowerOffset = 3
	StationPowerOffset_PA_DB_0           StationPowerOffset = 4
	StationPowerOffset_PA_DB_1           StationPowerOffset = 5
	StationPowerOffset_PA_DB_2           StationPowerOffset = 6
	StationPowerOffset_PA_DB_3           StationPowerOffset = 7
)

var StationPowerOffset_name = map[int32]string{
	0: "PA_DB_MINUS6",
	1: "PA_DB_MINUX4DOT77",
	2: "PA_DB_MINUS3",
	3: "PA_DB_MINUS1DOT77",
	4: "PA_DB_0",
	5: "PA_DB_1",
	6: "PA_DB_2",
	7: "PA_DB_3",
}

var StationPowerOffset_value = map[string]int32{
	"PA_DB_MINUS6":      0,
	"PA_DB_MINUX4DOT77": 1,
	"PA_DB_MINUS3":      2,
	"PA_DB_MINUS1DOT77": 3,
	"PA_DB_0":           4,
	"PA_DB_1":           5,
	"PA_DB_2":           6,
	"PA_DB_3":           7,
}

func (x StationPowerOffset) String() string {
	return proto.EnumName(StationPowerOffset_name, int32(x))
}

func (StationPowerOffset) EnumDescriptor() ([]byte, []int) {
	return fileDescriptor_49d6c0a03a213d51, []int{0}
}

type C1MessageType int32

const (
	C1MessageType_C1_MESSAGE_UNKNOWN       C1MessageType = 0
	C1MessageType_C1_GET_RNIBCELLS         C1MessageType = 1
	C1MessageType_C1_GET_RNIBUES           C1MessageType = 2
	C1MessageType_C1_GET_RNIBLINKS         C1MessageType = 3
	C1MessageType_C1_POST_HANDOVERS        C1MessageType = 4
	C1MessageType_C1_POST_RMMCONFIGURATION C1MessageType = 5
)

var C1MessageType_name = map[int32]string{
	0: "C1_MESSAGE_UNKNOWN",
	1: "C1_GET_RNIBCELLS",
	2: "C1_GET_RNIBUES",
	3: "C1_GET_RNIBLINKS",
	4: "C1_POST_HANDOVERS",
	5: "C1_POST_RMMCONFIGURATION",
}

var C1MessageType_value = map[string]int32{
	"C1_MESSAGE_UNKNOWN":       0,
	"C1_GET_RNIBCELLS":         1,
	"C1_GET_RNIBUES":           2,
	"C1_GET_RNIBLINKS":         3,
	"C1_POST_HANDOVERS":        4,
	"C1_POST_RMMCONFIGURATION": 5,
}

func (x C1MessageType) String() string {
	return proto.EnumName(C1MessageType_name, int32(x))
}

func (C1MessageType) EnumDescriptor() ([]byte, []int) {
	return fileDescriptor_49d6c0a03a213d51, []int{1}
}

type C1RNIBType int32

const (
	C1RNIBType_C1_RNIB_UNKNOWN C1RNIBType = 0
	C1RNIBType_C1_RNIB_CELL    C1RNIBType = 1
	C1RNIBType_C1_RNIB_UE      C1RNIBType = 2
	C1RNIBType_C1_RNIB_LINK    C1RNIBType = 3
)

var C1RNIBType_name = map[int32]string{
	0: "C1_RNIB_UNKNOWN",
	1: "C1_RNIB_CELL",
	2: "C1_RNIB_UE",
	3: "C1_RNIB_LINK",
}

var C1RNIBType_value = map[string]int32{
	"C1_RNIB_UNKNOWN": 0,
	"C1_RNIB_CELL":    1,
	"C1_RNIB_UE":      2,
	"C1_RNIB_LINK":    3,
}

func (x C1RNIBType) String() string {
	return proto.EnumName(C1RNIBType_name, int32(x))
}

func (C1RNIBType) EnumDescriptor() ([]byte, []int) {
	return fileDescriptor_49d6c0a03a213d51, []int{2}
}

type C1XICICPA int32

const (
	C1XICICPA_C1_XICIC_PA_DB_MINUS6      C1XICICPA = 0
	C1XICICPA_C1_XICIC_PA_DB_MINUX4DOT77 C1XICICPA = 1
	C1XICICPA_C1_XICIC_PA_DB_MINUS3      C1XICICPA = 2
	C1XICICPA_C1_XICIC_PA_DB_MINUS1DOT77 C1XICICPA = 3
	C1XICICPA_C1_XICIC_PA_DB_0           C1XICICPA = 4
	C1XICICPA_C1_XICIC_PA_DB_1           C1XICICPA = 5
	C1XICICPA_C1_XICIC_PA_DB_2           C1XICICPA = 6
	C1XICICPA_C1_XICIC_PA_DB_3           C1XICICPA = 7
)

var C1XICICPA_name = map[int32]string{
	0: "C1_XICIC_PA_DB_MINUS6",
	1: "C1_XICIC_PA_DB_MINUX4DOT77",
	2: "C1_XICIC_PA_DB_MINUS3",
	3: "C1_XICIC_PA_DB_MINUS1DOT77",
	4: "C1_XICIC_PA_DB_0",
	5: "C1_XICIC_PA_DB_1",
	6: "C1_XICIC_PA_DB_2",
	7: "C1_XICIC_PA_DB_3",
}

var C1XICICPA_value = map[string]int32{
	"C1_XICIC_PA_DB_MINUS6":      0,
	"C1_XICIC_PA_DB_MINUX4DOT77": 1,
	"C1_XICIC_PA_DB_MINUS3":      2,
	"C1_XICIC_PA_DB_MINUS1DOT77": 3,
	"C1_XICIC_PA_DB_0":           4,
	"C1_XICIC_PA_DB_1":           5,
	"C1_XICIC_PA_DB_2":           6,
	"C1_XICIC_PA_DB_3":           7,
}

func (x C1XICICPA) String() string {
	return proto.EnumName(C1XICICPA_name, int32(x))
}

func (C1XICICPA) EnumDescriptor() ([]byte, []int) {
	return fileDescriptor_49d6c0a03a213d51, []int{3}
}

// station's unique ID
type ECGI struct {
	Plmnid string `protobuf:"bytes,1,opt,name=plmnid,proto3" json:"plmnid,omitempty"`
	Ecid   string `protobuf:"bytes,2,opt,name=ecid,proto3" json:"ecid,omitempty"`
}

func (m *ECGI) Reset()         { *m = ECGI{} }
func (m *ECGI) String() string { return proto.CompactTextString(m) }
func (*ECGI) ProtoMessage()    {}
func (*ECGI) Descriptor() ([]byte, []int) {
	return fileDescriptor_49d6c0a03a213d51, []int{0}
}
func (m *ECGI) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *ECGI) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_ECGI.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *ECGI) XXX_Merge(src proto.Message) {
	xxx_messageInfo_ECGI.Merge(m, src)
}
func (m *ECGI) XXX_Size() int {
	return m.Size()
}
func (m *ECGI) XXX_DiscardUnknown() {
	xxx_messageInfo_ECGI.DiscardUnknown(m)
}

var xxx_messageInfo_ECGI proto.InternalMessageInfo

func (m *ECGI) GetPlmnid() string {
	if m != nil {
		return m.Plmnid
	}
	return ""
}

func (m *ECGI) GetEcid() string {
	if m != nil {
		return m.Ecid
	}
	return ""
}

// if ecgi is empty, stream all stations' information
type StationListRequest struct {
	// ecgi - optional station identifier - list for all stations if not present
	Ecgi *ECGI `protobuf:"bytes,1,opt,name=ecgi,proto3" json:"ecgi,omitempty"`
	// subscribe indicates whether to subscribe to events (e.g. ADD, UPDATE, and REMOVE) that occur
	// after all stations have been streamed to the client
	Subscribe bool `protobuf:"varint,2,opt,name=subscribe,proto3" json:"subscribe,omitempty"`
}

func (m *StationListRequest) Reset()         { *m = StationListRequest{} }
func (m *StationListRequest) String() string { return proto.CompactTextString(m) }
func (*StationListRequest) ProtoMessage()    {}
func (*StationListRequest) Descriptor() ([]byte, []int) {
	return fileDescriptor_49d6c0a03a213d51, []int{1}
}
func (m *StationListRequest) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *StationListRequest) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_StationListRequest.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *StationListRequest) XXX_Merge(src proto.Message) {
	xxx_messageInfo_StationListRequest.Merge(m, src)
}
func (m *StationListRequest) XXX_Size() int {
	return m.Size()
}
func (m *StationListRequest) XXX_DiscardUnknown() {
	xxx_messageInfo_StationListRequest.DiscardUnknown(m)
}

var xxx_messageInfo_StationListRequest proto.InternalMessageInfo

func (m *StationListRequest) GetEcgi() *ECGI {
	if m != nil {
		return m.Ecgi
	}
	return nil
}

func (m *StationListRequest) GetSubscribe() bool {
	if m != nil {
		return m.Subscribe
	}
	return false
}

type StationInfo struct {
	// station's unique ID
	Ecgi *ECGI `protobuf:"bytes,1,opt,name=ecgi,proto3" json:"ecgi,omitempty"`
	// station's maximum number of connected UEs - used for MLB
	MaxNumConnectedUes uint32 `protobuf:"varint,3,opt,name=maxNumConnectedUes,proto3" json:"maxNumConnectedUes,omitempty"`
}

func (m *StationInfo) Reset()         { *m = StationInfo{} }
func (m *StationInfo) String() string { return proto.CompactTextString(m) }
func (*StationInfo) ProtoMessage()    {}
func (*StationInfo) Descriptor() ([]byte, []int) {
	return fileDescriptor_49d6c0a03a213d51, []int{2}
}
func (m *StationInfo) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *StationInfo) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_StationInfo.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *StationInfo) XXX_Merge(src proto.Message) {
	xxx_messageInfo_StationInfo.Merge(m, src)
}
func (m *StationInfo) XXX_Size() int {
	return m.Size()
}
func (m *StationInfo) XXX_DiscardUnknown() {
	xxx_messageInfo_StationInfo.DiscardUnknown(m)
}

var xxx_messageInfo_StationInfo proto.InternalMessageInfo

func (m *StationInfo) GetEcgi() *ECGI {
	if m != nil {
		return m.Ecgi
	}
	return nil
}

func (m *StationInfo) GetMaxNumConnectedUes() uint32 {
	if m != nil {
		return m.MaxNumConnectedUes
	}
	return 0
}

// if ECGI is empty, stream all station links' information
type StationLinkListRequest struct {
	// ecgi - optional station identifier - list for all stations if not present
	Ecgi *ECGI `protobuf:"bytes,1,opt,name=ecgi,proto3" json:"ecgi,omitempty"`
	// subscribe indicates whether to subscribe to events (e.g. ADD, UPDATE, and REMOVE) that occur
	// after all stationlinks have been streamed to the client
	Subscribe bool `protobuf:"varint,2,opt,name=subscribe,proto3" json:"subscribe,omitempty"`
}

func (m *StationLinkListRequest) Reset()         { *m = StationLinkListRequest{} }
func (m *StationLinkListRequest) String() string { return proto.CompactTextString(m) }
func (*StationLinkListRequest) ProtoMessage()    {}
func (*StationLinkListRequest) Descriptor() ([]byte, []int) {
	return fileDescriptor_49d6c0a03a213d51, []int{3}
}
func (m *StationLinkListRequest) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *StationLinkListRequest) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_StationLinkListRequest.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *StationLinkListRequest) XXX_Merge(src proto.Message) {
	xxx_messageInfo_StationLinkListRequest.Merge(m, src)
}
func (m *StationLinkListRequest) XXX_Size() int {
	return m.Size()
}
func (m *StationLinkListRequest) XXX_DiscardUnknown() {
	xxx_messageInfo_StationLinkListRequest.DiscardUnknown(m)
}

var xxx_messageInfo_StationLinkListRequest proto.InternalMessageInfo

func (m *StationLinkListRequest) GetEcgi() *ECGI {
	if m != nil {
		return m.Ecgi
	}
	return nil
}

func (m *StationLinkListRequest) GetSubscribe() bool {
	if m != nil {
		return m.Subscribe
	}
	return false
}

type StationLinkInfo struct {
	// target station ID
	Ecgi *ECGI `protobuf:"bytes,1,opt,name=ecgi,proto3" json:"ecgi,omitempty"`
	// list of neighbor stations' ID
	NeighborECGI []*ECGI `protobuf:"bytes,2,rep,name=neighborECGI,proto3" json:"neighborECGI,omitempty"`
}

func (m *StationLinkInfo) Reset()         { *m = StationLinkInfo{} }
func (m *StationLinkInfo) String() string { return proto.CompactTextString(m) }
func (*StationLinkInfo) ProtoMessage()    {}
func (*StationLinkInfo) Descriptor() ([]byte, []int) {
	return fileDescriptor_49d6c0a03a213d51, []int{4}
}
func (m *StationLinkInfo) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *StationLinkInfo) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_StationLinkInfo.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *StationLinkInfo) XXX_Merge(src proto.Message) {
	xxx_messageInfo_StationLinkInfo.Merge(m, src)
}
func (m *StationLinkInfo) XXX_Size() int {
	return m.Size()
}
func (m *StationLinkInfo) XXX_DiscardUnknown() {
	xxx_messageInfo_StationLinkInfo.DiscardUnknown(m)
}

var xxx_messageInfo_StationLinkInfo proto.InternalMessageInfo

func (m *StationLinkInfo) GetEcgi() *ECGI {
	if m != nil {
		return m.Ecgi
	}
	return nil
}

func (m *StationLinkInfo) GetNeighborECGI() []*ECGI {
	if m != nil {
		return m.NeighborECGI
	}
	return nil
}

// if crnti and ecgi are empty, stream all UE links' information
type UELinkListRequest struct {
	// crnti - optional UE's local ID in serving station  - list for all UE local IDs if not present
	Crnti string `protobuf:"bytes,1,opt,name=crnti,proto3" json:"crnti,omitempty"`
	// ecgi - optional UE's serving station identifier - list for all stations if not present
	Ecgi *ECGI `protobuf:"bytes,2,opt,name=ecgi,proto3" json:"ecgi,omitempty"`
	// subscribe indicates whether to subscribe to events (e.g. ADD, UPDATE, and REMOVE) that occur
	// after all uelinks have been streamed to the client
	Subscribe bool `protobuf:"varint,3,opt,name=subscribe,proto3" json:"subscribe,omitempty"`
	// noReplay - do not replay the list of UELinks from before the request
	// Used with subscribe, to only get new changes
	NoReplay bool `protobuf:"varint,4,opt,name=noReplay,proto3" json:"noReplay,omitempty"`
}

func (m *UELinkListRequest) Reset()         { *m = UELinkListRequest{} }
func (m *UELinkListRequest) String() string { return proto.CompactTextString(m) }
func (*UELinkListRequest) ProtoMessage()    {}
func (*UELinkListRequest) Descriptor() ([]byte, []int) {
	return fileDescriptor_49d6c0a03a213d51, []int{5}
}
func (m *UELinkListRequest) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *UELinkListRequest) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_UELinkListRequest.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *UELinkListRequest) XXX_Merge(src proto.Message) {
	xxx_messageInfo_UELinkListRequest.Merge(m, src)
}
func (m *UELinkListRequest) XXX_Size() int {
	return m.Size()
}
func (m *UELinkListRequest) XXX_DiscardUnknown() {
	xxx_messageInfo_UELinkListRequest.DiscardUnknown(m)
}

var xxx_messageInfo_UELinkListRequest proto.InternalMessageInfo

func (m *UELinkListRequest) GetCrnti() string {
	if m != nil {
		return m.Crnti
	}
	return ""
}

func (m *UELinkListRequest) GetEcgi() *ECGI {
	if m != nil {
		return m.Ecgi
	}
	return nil
}

func (m *UELinkListRequest) GetSubscribe() bool {
	if m != nil {
		return m.Subscribe
	}
	return false
}

func (m *UELinkListRequest) GetNoReplay() bool {
	if m != nil {
		return m.NoReplay
	}
	return false
}

type ChannelQuality struct {
	// Target stations's ID
	// This target station can be either the serving station or the serving station's neighbor stations.
	TargetEcgi *ECGI `protobuf:"bytes,1,opt,name=targetEcgi,proto3" json:"targetEcgi,omitempty"`
	// CQI stands for Channel Quality Indicator in LTE, which ranges from 0 (out of range) to 15 (64 QAM and 948 Code rate)
	CqiHist uint32 `protobuf:"varint,2,opt,name=cqiHist,proto3" json:"cqiHist,omitempty"`
}

func (m *ChannelQuality) Reset()         { *m = ChannelQuality{} }
func (m *ChannelQuality) String() string { return proto.CompactTextString(m) }
func (*ChannelQuality) ProtoMessage()    {}
func (*ChannelQuality) Descriptor() ([]byte, []int) {
	return fileDescriptor_49d6c0a03a213d51, []int{6}
}
func (m *ChannelQuality) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *ChannelQuality) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_ChannelQuality.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *ChannelQuality) XXX_Merge(src proto.Message) {
	xxx_messageInfo_ChannelQuality.Merge(m, src)
}
func (m *ChannelQuality) XXX_Size() int {
	return m.Size()
}
func (m *ChannelQuality) XXX_DiscardUnknown() {
	xxx_messageInfo_ChannelQuality.DiscardUnknown(m)
}

var xxx_messageInfo_ChannelQuality proto.InternalMessageInfo

func (m *ChannelQuality) GetTargetEcgi() *ECGI {
	if m != nil {
		return m.TargetEcgi
	}
	return nil
}

func (m *ChannelQuality) GetCqiHist() uint32 {
	if m != nil {
		return m.CqiHist
	}
	return 0
}

// It shows the link quality between the UE -- having crnti (1) and serviced by the station having ecgi (2) -- and the station -- having targetECGI (3).
// Target station can be not only UE's serving station but also the station's neighbor stations.
type UELinkInfo struct {
	// Both crnti and ecgi are used as a key in our store.
	// UE's local ID in serving station
	Crnti string `protobuf:"bytes,1,opt,name=crnti,proto3" json:"crnti,omitempty"`
	// UE's serving station ID
	Ecgi *ECGI `protobuf:"bytes,2,opt,name=ecgi,proto3" json:"ecgi,omitempty"`
	// Channel quality values between the UE and its serving or neighbor stations.
	ChannelQualities []*ChannelQuality `protobuf:"bytes,3,rep,name=channelQualities,proto3" json:"channelQualities,omitempty"`
	// optional value: IMSI which is a global unique UE ID
	// This value is from UEContextUpdate message
	// The crnti is local ID only working in a serving base station. However, sometimes an app may need the unique ID
	// Thus, add IMSI as an optional.
	Imsi string `protobuf:"bytes,4,opt,name=imsi,proto3" json:"imsi,omitempty"`
}

func (m *UELinkInfo) Reset()         { *m = UELinkInfo{} }
func (m *UELinkInfo) String() string { return proto.CompactTextString(m) }
func (*UELinkInfo) ProtoMessage()    {}
func (*UELinkInfo) Descriptor() ([]byte, []int) {
	return fileDescriptor_49d6c0a03a213d51, []int{7}
}
func (m *UELinkInfo) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *UELinkInfo) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_UELinkInfo.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *UELinkInfo) XXX_Merge(src proto.Message) {
	xxx_messageInfo_UELinkInfo.Merge(m, src)
}
func (m *UELinkInfo) XXX_Size() int {
	return m.Size()
}
func (m *UELinkInfo) XXX_DiscardUnknown() {
	xxx_messageInfo_UELinkInfo.DiscardUnknown(m)
}

var xxx_messageInfo_UELinkInfo proto.InternalMessageInfo

func (m *UELinkInfo) GetCrnti() string {
	if m != nil {
		return m.Crnti
	}
	return ""
}

func (m *UELinkInfo) GetEcgi() *ECGI {
	if m != nil {
		return m.Ecgi
	}
	return nil
}

func (m *UELinkInfo) GetChannelQualities() []*ChannelQuality {
	if m != nil {
		return m.ChannelQualities
	}
	return nil
}

func (m *UELinkInfo) GetImsi() string {
	if m != nil {
		return m.Imsi
	}
	return ""
}

type HandOverRequest struct {
	// UE's local ID in serving station
	Crnti string `protobuf:"bytes,1,opt,name=crnti,proto3" json:"crnti,omitempty"`
	// UE's source station ID - serving station
	SrcStation *ECGI `protobuf:"bytes,2,opt,name=srcStation,proto3" json:"srcStation,omitempty"`
	// UE's destination station ID for handover - one of neighbor stations
	DstStation *ECGI `protobuf:"bytes,3,opt,name=dstStation,proto3" json:"dstStation,omitempty"`
}

func (m *HandOverRequest) Reset()         { *m = HandOverRequest{} }
func (m *HandOverRequest) String() string { return proto.CompactTextString(m) }
func (*HandOverRequest) ProtoMessage()    {}
func (*HandOverRequest) Descriptor() ([]byte, []int) {
	return fileDescriptor_49d6c0a03a213d51, []int{8}
}
func (m *HandOverRequest) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *HandOverRequest) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_HandOverRequest.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *HandOverRequest) XXX_Merge(src proto.Message) {
	xxx_messageInfo_HandOverRequest.Merge(m, src)
}
func (m *HandOverRequest) XXX_Size() int {
	return m.Size()
}
func (m *HandOverRequest) XXX_DiscardUnknown() {
	xxx_messageInfo_HandOverRequest.DiscardUnknown(m)
}

var xxx_messageInfo_HandOverRequest proto.InternalMessageInfo

func (m *HandOverRequest) GetCrnti() string {
	if m != nil {
		return m.Crnti
	}
	return ""
}

func (m *HandOverRequest) GetSrcStation() *ECGI {
	if m != nil {
		return m.SrcStation
	}
	return nil
}

func (m *HandOverRequest) GetDstStation() *ECGI {
	if m != nil {
		return m.DstStation
	}
	return nil
}

type HandOverResponse struct {
	Success bool `protobuf:"varint,1,opt,name=success,proto3" json:"success,omitempty"`
}

func (m *HandOverResponse) Reset()         { *m = HandOverResponse{} }
func (m *HandOverResponse) String() string { return proto.CompactTextString(m) }
func (*HandOverResponse) ProtoMessage()    {}
func (*HandOverResponse) Descriptor() ([]byte, []int) {
	return fileDescriptor_49d6c0a03a213d51, []int{9}
}
func (m *HandOverResponse) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *HandOverResponse) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_HandOverResponse.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *HandOverResponse) XXX_Merge(src proto.Message) {
	xxx_messageInfo_HandOverResponse.Merge(m, src)
}
func (m *HandOverResponse) XXX_Size() int {
	return m.Size()
}
func (m *HandOverResponse) XXX_DiscardUnknown() {
	xxx_messageInfo_HandOverResponse.DiscardUnknown(m)
}

var xxx_messageInfo_HandOverResponse proto.InternalMessageInfo

func (m *HandOverResponse) GetSuccess() bool {
	if m != nil {
		return m.Success
	}
	return false
}

type RadioPowerRequest struct {
	// target station's ID
	Ecgi *ECGI `protobuf:"bytes,1,opt,name=ecgi,proto3" json:"ecgi,omitempty"`
	// target station's power offset to adjust transmission power
	Offset StationPowerOffset `protobuf:"varint,2,opt,name=offset,proto3,enum=interface.c1.StationPowerOffset" json:"offset,omitempty"`
}

func (m *RadioPowerRequest) Reset()         { *m = RadioPowerRequest{} }
func (m *RadioPowerRequest) String() string { return proto.CompactTextString(m) }
func (*RadioPowerRequest) ProtoMessage()    {}
func (*RadioPowerRequest) Descriptor() ([]byte, []int) {
	return fileDescriptor_49d6c0a03a213d51, []int{10}
}
func (m *RadioPowerRequest) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *RadioPowerRequest) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_RadioPowerRequest.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *RadioPowerRequest) XXX_Merge(src proto.Message) {
	xxx_messageInfo_RadioPowerRequest.Merge(m, src)
}
func (m *RadioPowerRequest) XXX_Size() int {
	return m.Size()
}
func (m *RadioPowerRequest) XXX_DiscardUnknown() {
	xxx_messageInfo_RadioPowerRequest.DiscardUnknown(m)
}

var xxx_messageInfo_RadioPowerRequest proto.InternalMessageInfo

func (m *RadioPowerRequest) GetEcgi() *ECGI {
	if m != nil {
		return m.Ecgi
	}
	return nil
}

func (m *RadioPowerRequest) GetOffset() StationPowerOffset {
	if m != nil {
		return m.Offset
	}
	return StationPowerOffset_PA_DB_MINUS6
}

type RadioPowerResponse struct {
	Success bool `protobuf:"varint,1,opt,name=success,proto3" json:"success,omitempty"`
}

func (m *RadioPowerResponse) Reset()         { *m = RadioPowerResponse{} }
func (m *RadioPowerResponse) String() string { return proto.CompactTextString(m) }
func (*RadioPowerResponse) ProtoMessage()    {}
func (*RadioPowerResponse) Descriptor() ([]byte, []int) {
	return fileDescriptor_49d6c0a03a213d51, []int{11}
}
func (m *RadioPowerResponse) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *RadioPowerResponse) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_RadioPowerResponse.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *RadioPowerResponse) XXX_Merge(src proto.Message) {
	xxx_messageInfo_RadioPowerResponse.Merge(m, src)
}
func (m *RadioPowerResponse) XXX_Size() int {
	return m.Size()
}
func (m *RadioPowerResponse) XXX_DiscardUnknown() {
	xxx_messageInfo_RadioPowerResponse.DiscardUnknown(m)
}

var xxx_messageInfo_RadioPowerResponse proto.InternalMessageInfo

func (m *RadioPowerResponse) GetSuccess() bool {
	if m != nil {
		return m.Success
	}
	return false
}

type C1RequestMessage struct {
	Header  *C1RequestMessageHeader  `protobuf:"bytes,1,opt,name=header,proto3" json:"header,omitempty"`
	Payload *C1RequestMessagePayload `protobuf:"bytes,2,opt,name=payload,proto3" json:"payload,omitempty"`
}

func (m *C1RequestMessage) Reset()         { *m = C1RequestMessage{} }
func (m *C1RequestMessage) String() string { return proto.CompactTextString(m) }
func (*C1RequestMessage) ProtoMessage()    {}
func (*C1RequestMessage) Descriptor() ([]byte, []int) {
	return fileDescriptor_49d6c0a03a213d51, []int{12}
}
func (m *C1RequestMessage) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *C1RequestMessage) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_C1RequestMessage.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *C1RequestMessage) XXX_Merge(src proto.Message) {
	xxx_messageInfo_C1RequestMessage.Merge(m, src)
}
func (m *C1RequestMessage) XXX_Size() int {
	return m.Size()
}
func (m *C1RequestMessage) XXX_DiscardUnknown() {
	xxx_messageInfo_C1RequestMessage.DiscardUnknown(m)
}

var xxx_messageInfo_C1RequestMessage proto.InternalMessageInfo

func (m *C1RequestMessage) GetHeader() *C1RequestMessageHeader {
	if m != nil {
		return m.Header
	}
	return nil
}

func (m *C1RequestMessage) GetPayload() *C1RequestMessagePayload {
	if m != nil {
		return m.Payload
	}
	return nil
}

type C1ResponseMessage struct {
	Header  *C1ResponseMessageHeader  `protobuf:"bytes,1,opt,name=header,proto3" json:"header,omitempty"`
	Payload *C1ResponseMessagePayload `protobuf:"bytes,2,opt,name=payload,proto3" json:"payload,omitempty"`
}

func (m *C1ResponseMessage) Reset()         { *m = C1ResponseMessage{} }
func (m *C1ResponseMessage) String() string { return proto.CompactTextString(m) }
func (*C1ResponseMessage) ProtoMessage()    {}
func (*C1ResponseMessage) Descriptor() ([]byte, []int) {
	return fileDescriptor_49d6c0a03a213d51, []int{13}
}
func (m *C1ResponseMessage) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *C1ResponseMessage) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_C1ResponseMessage.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *C1ResponseMessage) XXX_Merge(src proto.Message) {
	xxx_messageInfo_C1ResponseMessage.Merge(m, src)
}
func (m *C1ResponseMessage) XXX_Size() int {
	return m.Size()
}
func (m *C1ResponseMessage) XXX_DiscardUnknown() {
	xxx_messageInfo_C1ResponseMessage.DiscardUnknown(m)
}

var xxx_messageInfo_C1ResponseMessage proto.InternalMessageInfo

func (m *C1ResponseMessage) GetHeader() *C1ResponseMessageHeader {
	if m != nil {
		return m.Header
	}
	return nil
}

func (m *C1ResponseMessage) GetPayload() *C1ResponseMessagePayload {
	if m != nil {
		return m.Payload
	}
	return nil
}

type C1RequestMessageHeader struct {
	Type C1MessageType `protobuf:"varint,1,opt,name=type,proto3,enum=interface.c1.C1MessageType" json:"type,omitempty"`
}

func (m *C1RequestMessageHeader) Reset()         { *m = C1RequestMessageHeader{} }
func (m *C1RequestMessageHeader) String() string { return proto.CompactTextString(m) }
func (*C1RequestMessageHeader) ProtoMessage()    {}
func (*C1RequestMessageHeader) Descriptor() ([]byte, []int) {
	return fileDescriptor_49d6c0a03a213d51, []int{14}
}
func (m *C1RequestMessageHeader) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *C1RequestMessageHeader) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_C1RequestMessageHeader.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *C1RequestMessageHeader) XXX_Merge(src proto.Message) {
	xxx_messageInfo_C1RequestMessageHeader.Merge(m, src)
}
func (m *C1RequestMessageHeader) XXX_Size() int {
	return m.Size()
}
func (m *C1RequestMessageHeader) XXX_DiscardUnknown() {
	xxx_messageInfo_C1RequestMessageHeader.DiscardUnknown(m)
}

var xxx_messageInfo_C1RequestMessageHeader proto.InternalMessageInfo

func (m *C1RequestMessageHeader) GetType() C1MessageType {
	if m != nil {
		return m.Type
	}
	return C1MessageType_C1_MESSAGE_UNKNOWN
}

type C1RequestMessagePayload struct {
	// Types that are valid to be assigned to Request:
	//	*C1RequestMessagePayload_RequestedRNIBType
	//	*C1RequestMessagePayload_HandoverRequest
	//	*C1RequestMessagePayload_RrmConfigurationRequest
	Request isC1RequestMessagePayload_Request `protobuf_oneof:"request"`
}

func (m *C1RequestMessagePayload) Reset()         { *m = C1RequestMessagePayload{} }
func (m *C1RequestMessagePayload) String() string { return proto.CompactTextString(m) }
func (*C1RequestMessagePayload) ProtoMessage()    {}
func (*C1RequestMessagePayload) Descriptor() ([]byte, []int) {
	return fileDescriptor_49d6c0a03a213d51, []int{15}
}
func (m *C1RequestMessagePayload) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *C1RequestMessagePayload) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_C1RequestMessagePayload.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *C1RequestMessagePayload) XXX_Merge(src proto.Message) {
	xxx_messageInfo_C1RequestMessagePayload.Merge(m, src)
}
func (m *C1RequestMessagePayload) XXX_Size() int {
	return m.Size()
}
func (m *C1RequestMessagePayload) XXX_DiscardUnknown() {
	xxx_messageInfo_C1RequestMessagePayload.DiscardUnknown(m)
}

var xxx_messageInfo_C1RequestMessagePayload proto.InternalMessageInfo

type isC1RequestMessagePayload_Request interface {
	isC1RequestMessagePayload_Request()
	MarshalTo([]byte) (int, error)
	Size() int
}

type C1RequestMessagePayload_RequestedRNIBType struct {
	RequestedRNIBType C1RNIBType `protobuf:"varint,1,opt,name=requestedRNIBType,proto3,enum=interface.c1.C1RNIBType,oneof" json:"requestedRNIBType,omitempty"`
}
type C1RequestMessagePayload_HandoverRequest struct {
	HandoverRequest *C1HandoverRequest `protobuf:"bytes,2,opt,name=handoverRequest,proto3,oneof" json:"handoverRequest,omitempty"`
}
type C1RequestMessagePayload_RrmConfigurationRequest struct {
	RrmConfigurationRequest *C1RRMConfiguration `protobuf:"bytes,3,opt,name=rrmConfigurationRequest,proto3,oneof" json:"rrmConfigurationRequest,omitempty"`
}

func (*C1RequestMessagePayload_RequestedRNIBType) isC1RequestMessagePayload_Request()       {}
func (*C1RequestMessagePayload_HandoverRequest) isC1RequestMessagePayload_Request()         {}
func (*C1RequestMessagePayload_RrmConfigurationRequest) isC1RequestMessagePayload_Request() {}

func (m *C1RequestMessagePayload) GetRequest() isC1RequestMessagePayload_Request {
	if m != nil {
		return m.Request
	}
	return nil
}

func (m *C1RequestMessagePayload) GetRequestedRNIBType() C1RNIBType {
	if x, ok := m.GetRequest().(*C1RequestMessagePayload_RequestedRNIBType); ok {
		return x.RequestedRNIBType
	}
	return C1RNIBType_C1_RNIB_UNKNOWN
}

func (m *C1RequestMessagePayload) GetHandoverRequest() *C1HandoverRequest {
	if x, ok := m.GetRequest().(*C1RequestMessagePayload_HandoverRequest); ok {
		return x.HandoverRequest
	}
	return nil
}

func (m *C1RequestMessagePayload) GetRrmConfigurationRequest() *C1RRMConfiguration {
	if x, ok := m.GetRequest().(*C1RequestMessagePayload_RrmConfigurationRequest); ok {
		return x.RrmConfigurationRequest
	}
	return nil
}

// XXX_OneofWrappers is for the internal use of the proto package.
func (*C1RequestMessagePayload) XXX_OneofWrappers() []interface{} {
	return []interface{}{
		(*C1RequestMessagePayload_RequestedRNIBType)(nil),
		(*C1RequestMessagePayload_HandoverRequest)(nil),
		(*C1RequestMessagePayload_RrmConfigurationRequest)(nil),
	}
}

type C1ResponseMessageHeader struct {
	Type C1MessageType `protobuf:"varint,1,opt,name=type,proto3,enum=interface.c1.C1MessageType" json:"type,omitempty"`
}

func (m *C1ResponseMessageHeader) Reset()         { *m = C1ResponseMessageHeader{} }
func (m *C1ResponseMessageHeader) String() string { return proto.CompactTextString(m) }
func (*C1ResponseMessageHeader) ProtoMessage()    {}
func (*C1ResponseMessageHeader) Descriptor() ([]byte, []int) {
	return fileDescriptor_49d6c0a03a213d51, []int{16}
}
func (m *C1ResponseMessageHeader) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *C1ResponseMessageHeader) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_C1ResponseMessageHeader.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *C1ResponseMessageHeader) XXX_Merge(src proto.Message) {
	xxx_messageInfo_C1ResponseMessageHeader.Merge(m, src)
}
func (m *C1ResponseMessageHeader) XXX_Size() int {
	return m.Size()
}
func (m *C1ResponseMessageHeader) XXX_DiscardUnknown() {
	xxx_messageInfo_C1ResponseMessageHeader.DiscardUnknown(m)
}

var xxx_messageInfo_C1ResponseMessageHeader proto.InternalMessageInfo

func (m *C1ResponseMessageHeader) GetType() C1MessageType {
	if m != nil {
		return m.Type
	}
	return C1MessageType_C1_MESSAGE_UNKNOWN
}

type C1ResponseMessagePayload struct {
	// Types that are valid to be assigned to Result:
	//	*C1ResponseMessagePayload_ResponseCode
	//	*C1ResponseMessagePayload_RNIBCells
	//	*C1ResponseMessagePayload_RNIBUEs
	//	*C1ResponseMessagePayload_RNIBLinks
	Result isC1ResponseMessagePayload_Result `protobuf_oneof:"result"`
}

func (m *C1ResponseMessagePayload) Reset()         { *m = C1ResponseMessagePayload{} }
func (m *C1ResponseMessagePayload) String() string { return proto.CompactTextString(m) }
func (*C1ResponseMessagePayload) ProtoMessage()    {}
func (*C1ResponseMessagePayload) Descriptor() ([]byte, []int) {
	return fileDescriptor_49d6c0a03a213d51, []int{17}
}
func (m *C1ResponseMessagePayload) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *C1ResponseMessagePayload) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_C1ResponseMessagePayload.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *C1ResponseMessagePayload) XXX_Merge(src proto.Message) {
	xxx_messageInfo_C1ResponseMessagePayload.Merge(m, src)
}
func (m *C1ResponseMessagePayload) XXX_Size() int {
	return m.Size()
}
func (m *C1ResponseMessagePayload) XXX_DiscardUnknown() {
	xxx_messageInfo_C1ResponseMessagePayload.DiscardUnknown(m)
}

var xxx_messageInfo_C1ResponseMessagePayload proto.InternalMessageInfo

type isC1ResponseMessagePayload_Result interface {
	isC1ResponseMessagePayload_Result()
	MarshalTo([]byte) (int, error)
	Size() int
}

type C1ResponseMessagePayload_ResponseCode struct {
	ResponseCode string `protobuf:"bytes,1,opt,name=responseCode,proto3,oneof" json:"responseCode,omitempty"`
}
type C1ResponseMessagePayload_RNIBCells struct {
	RNIBCells *C1RNIBCells `protobuf:"bytes,2,opt,name=rNIBCells,proto3,oneof" json:"rNIBCells,omitempty"`
}
type C1ResponseMessagePayload_RNIBUEs struct {
	RNIBUEs *C1RNIBUEs `protobuf:"bytes,3,opt,name=rNIBUEs,proto3,oneof" json:"rNIBUEs,omitempty"`
}
type C1ResponseMessagePayload_RNIBLinks struct {
	RNIBLinks *C1RNIBLinks `protobuf:"bytes,4,opt,name=rNIBLinks,proto3,oneof" json:"rNIBLinks,omitempty"`
}

func (*C1ResponseMessagePayload_ResponseCode) isC1ResponseMessagePayload_Result() {}
func (*C1ResponseMessagePayload_RNIBCells) isC1ResponseMessagePayload_Result()    {}
func (*C1ResponseMessagePayload_RNIBUEs) isC1ResponseMessagePayload_Result()      {}
func (*C1ResponseMessagePayload_RNIBLinks) isC1ResponseMessagePayload_Result()    {}

func (m *C1ResponseMessagePayload) GetResult() isC1ResponseMessagePayload_Result {
	if m != nil {
		return m.Result
	}
	return nil
}

func (m *C1ResponseMessagePayload) GetResponseCode() string {
	if x, ok := m.GetResult().(*C1ResponseMessagePayload_ResponseCode); ok {
		return x.ResponseCode
	}
	return ""
}

func (m *C1ResponseMessagePayload) GetRNIBCells() *C1RNIBCells {
	if x, ok := m.GetResult().(*C1ResponseMessagePayload_RNIBCells); ok {
		return x.RNIBCells
	}
	return nil
}

func (m *C1ResponseMessagePayload) GetRNIBUEs() *C1RNIBUEs {
	if x, ok := m.GetResult().(*C1ResponseMessagePayload_RNIBUEs); ok {
		return x.RNIBUEs
	}
	return nil
}

func (m *C1ResponseMessagePayload) GetRNIBLinks() *C1RNIBLinks {
	if x, ok := m.GetResult().(*C1ResponseMessagePayload_RNIBLinks); ok {
		return x.RNIBLinks
	}
	return nil
}

// XXX_OneofWrappers is for the internal use of the proto package.
func (*C1ResponseMessagePayload) XXX_OneofWrappers() []interface{} {
	return []interface{}{
		(*C1ResponseMessagePayload_ResponseCode)(nil),
		(*C1ResponseMessagePayload_RNIBCells)(nil),
		(*C1ResponseMessagePayload_RNIBUEs)(nil),
		(*C1ResponseMessagePayload_RNIBLinks)(nil),
	}
}

type C1RNIBCells struct {
	RNIBCells []*C1RNIBCell `protobuf:"bytes,1,rep,name=rNIBCells,proto3" json:"rNIBCells,omitempty"`
}

func (m *C1RNIBCells) Reset()         { *m = C1RNIBCells{} }
func (m *C1RNIBCells) String() string { return proto.CompactTextString(m) }
func (*C1RNIBCells) ProtoMessage()    {}
func (*C1RNIBCells) Descriptor() ([]byte, []int) {
	return fileDescriptor_49d6c0a03a213d51, []int{18}
}
func (m *C1RNIBCells) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *C1RNIBCells) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_C1RNIBCells.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *C1RNIBCells) XXX_Merge(src proto.Message) {
	xxx_messageInfo_C1RNIBCells.Merge(m, src)
}
func (m *C1RNIBCells) XXX_Size() int {
	return m.Size()
}
func (m *C1RNIBCells) XXX_DiscardUnknown() {
	xxx_messageInfo_C1RNIBCells.DiscardUnknown(m)
}

var xxx_messageInfo_C1RNIBCells proto.InternalMessageInfo

func (m *C1RNIBCells) GetRNIBCells() []*C1RNIBCell {
	if m != nil {
		return m.RNIBCells
	}
	return nil
}

type C1RNIBUEs struct {
	RNIBUEs []*C1RNIBUE `protobuf:"bytes,1,rep,name=rNIBUEs,proto3" json:"rNIBUEs,omitempty"`
}

func (m *C1RNIBUEs) Reset()         { *m = C1RNIBUEs{} }
func (m *C1RNIBUEs) String() string { return proto.CompactTextString(m) }
func (*C1RNIBUEs) ProtoMessage()    {}
func (*C1RNIBUEs) Descriptor() ([]byte, []int) {
	return fileDescriptor_49d6c0a03a213d51, []int{19}
}
func (m *C1RNIBUEs) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *C1RNIBUEs) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_C1RNIBUEs.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *C1RNIBUEs) XXX_Merge(src proto.Message) {
	xxx_messageInfo_C1RNIBUEs.Merge(m, src)
}
func (m *C1RNIBUEs) XXX_Size() int {
	return m.Size()
}
func (m *C1RNIBUEs) XXX_DiscardUnknown() {
	xxx_messageInfo_C1RNIBUEs.DiscardUnknown(m)
}

var xxx_messageInfo_C1RNIBUEs proto.InternalMessageInfo

func (m *C1RNIBUEs) GetRNIBUEs() []*C1RNIBUE {
	if m != nil {
		return m.RNIBUEs
	}
	return nil
}

type C1RNIBLinks struct {
	RNIBLinks []*C1RNIBLink `protobuf:"bytes,1,rep,name=rNIBLinks,proto3" json:"rNIBLinks,omitempty"`
}

func (m *C1RNIBLinks) Reset()         { *m = C1RNIBLinks{} }
func (m *C1RNIBLinks) String() string { return proto.CompactTextString(m) }
func (*C1RNIBLinks) ProtoMessage()    {}
func (*C1RNIBLinks) Descriptor() ([]byte, []int) {
	return fileDescriptor_49d6c0a03a213d51, []int{20}
}
func (m *C1RNIBLinks) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *C1RNIBLinks) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_C1RNIBLinks.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *C1RNIBLinks) XXX_Merge(src proto.Message) {
	xxx_messageInfo_C1RNIBLinks.Merge(m, src)
}
func (m *C1RNIBLinks) XXX_Size() int {
	return m.Size()
}
func (m *C1RNIBLinks) XXX_DiscardUnknown() {
	xxx_messageInfo_C1RNIBLinks.DiscardUnknown(m)
}

var xxx_messageInfo_C1RNIBLinks proto.InternalMessageInfo

func (m *C1RNIBLinks) GetRNIBLinks() []*C1RNIBLink {
	if m != nil {
		return m.RNIBLinks
	}
	return nil
}

type C1ECGI struct {
	PlmnId string `protobuf:"bytes,1,opt,name=plmnId,proto3" json:"plmnId,omitempty"`
	Ecid   string `protobuf:"bytes,2,opt,name=ecid,proto3" json:"ecid,omitempty"`
}

func (m *C1ECGI) Reset()         { *m = C1ECGI{} }
func (m *C1ECGI) String() string { return proto.CompactTextString(m) }
func (*C1ECGI) ProtoMessage()    {}
func (*C1ECGI) Descriptor() ([]byte, []int) {
	return fileDescriptor_49d6c0a03a213d51, []int{21}
}
func (m *C1ECGI) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *C1ECGI) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_C1ECGI.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *C1ECGI) XXX_Merge(src proto.Message) {
	xxx_messageInfo_C1ECGI.Merge(m, src)
}
func (m *C1ECGI) XXX_Size() int {
	return m.Size()
}
func (m *C1ECGI) XXX_DiscardUnknown() {
	xxx_messageInfo_C1ECGI.DiscardUnknown(m)
}

var xxx_messageInfo_C1ECGI proto.InternalMessageInfo

func (m *C1ECGI) GetPlmnId() string {
	if m != nil {
		return m.PlmnId
	}
	return ""
}

func (m *C1ECGI) GetEcid() string {
	if m != nil {
		return m.Ecid
	}
	return ""
}

type C1CandScell struct {
	Pci      string `protobuf:"bytes,1,opt,name=pci,proto3" json:"pci,omitempty"`
	EarfcnDl string `protobuf:"bytes,2,opt,name=earfcnDl,proto3" json:"earfcnDl,omitempty"`
}

func (m *C1CandScell) Reset()         { *m = C1CandScell{} }
func (m *C1CandScell) String() string { return proto.CompactTextString(m) }
func (*C1CandScell) ProtoMessage()    {}
func (*C1CandScell) Descriptor() ([]byte, []int) {
	return fileDescriptor_49d6c0a03a213d51, []int{22}
}
func (m *C1CandScell) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *C1CandScell) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_C1CandScell.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *C1CandScell) XXX_Merge(src proto.Message) {
	xxx_messageInfo_C1CandScell.Merge(m, src)
}
func (m *C1CandScell) XXX_Size() int {
	return m.Size()
}
func (m *C1CandScell) XXX_DiscardUnknown() {
	xxx_messageInfo_C1CandScell.DiscardUnknown(m)
}

var xxx_messageInfo_C1CandScell proto.InternalMessageInfo

func (m *C1CandScell) GetPci() string {
	if m != nil {
		return m.Pci
	}
	return ""
}

func (m *C1CandScell) GetEarfcnDl() string {
	if m != nil {
		return m.EarfcnDl
	}
	return ""
}

type C1RNIBCell struct {
	Ecgi *C1ECGI `protobuf:"bytes,1,opt,name=ecgi,proto3" json:"ecgi,omitempty"`
	// attributes of R-NIB Cell
	// for Cell Configuration
	CellConfiguration *C1CellConfigAttribute `protobuf:"bytes,2,opt,name=cellConfiguration,proto3" json:"cellConfiguration,omitempty"`
	// for RRM configuration
	RrmConfiguration *C1RRMConfigAttribute `protobuf:"bytes,3,opt,name=rrmConfiguration,proto3" json:"rrmConfiguration,omitempty"`
}

func (m *C1RNIBCell) Reset()         { *m = C1RNIBCell{} }
func (m *C1RNIBCell) String() string { return proto.CompactTextString(m) }
func (*C1RNIBCell) ProtoMessage()    {}
func (*C1RNIBCell) Descriptor() ([]byte, []int) {
	return fileDescriptor_49d6c0a03a213d51, []int{23}
}
func (m *C1RNIBCell) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *C1RNIBCell) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_C1RNIBCell.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *C1RNIBCell) XXX_Merge(src proto.Message) {
	xxx_messageInfo_C1RNIBCell.Merge(m, src)
}
func (m *C1RNIBCell) XXX_Size() int {
	return m.Size()
}
func (m *C1RNIBCell) XXX_DiscardUnknown() {
	xxx_messageInfo_C1RNIBCell.DiscardUnknown(m)
}

var xxx_messageInfo_C1RNIBCell proto.InternalMessageInfo

func (m *C1RNIBCell) GetEcgi() *C1ECGI {
	if m != nil {
		return m.Ecgi
	}
	return nil
}

func (m *C1RNIBCell) GetCellConfiguration() *C1CellConfigAttribute {
	if m != nil {
		return m.CellConfiguration
	}
	return nil
}

func (m *C1RNIBCell) GetRrmConfiguration() *C1RRMConfigAttribute {
	if m != nil {
		return m.RrmConfiguration
	}
	return nil
}

type C1CellConfigAttribute struct {
	Ecgi                   *C1ECGI        `protobuf:"bytes,1,opt,name=ecgi,proto3" json:"ecgi,omitempty"`
	Pci                    string         `protobuf:"bytes,2,opt,name=pci,proto3" json:"pci,omitempty"`
	CandScells             []*C1CandScell `protobuf:"bytes,3,rep,name=candScells,proto3" json:"candScells,omitempty"`
	EarfcnDl               string         `protobuf:"bytes,4,opt,name=earfcnDl,proto3" json:"earfcnDl,omitempty"`
	EarfcnUl               string         `protobuf:"bytes,5,opt,name=earfcnUl,proto3" json:"earfcnUl,omitempty"`
	RbsPerTtiDl            string         `protobuf:"bytes,6,opt,name=rbsPerTtiDl,proto3" json:"rbsPerTtiDl,omitempty"`
	RbsPerTtiUl            string         `protobuf:"bytes,7,opt,name=rbsPerTtiUl,proto3" json:"rbsPerTtiUl,omitempty"`
	NumTxAntenna           string         `protobuf:"bytes,8,opt,name=numTxAntenna,proto3" json:"numTxAntenna,omitempty"`
	DuplexMode             string         `protobuf:"bytes,9,opt,name=duplexMode,proto3" json:"duplexMode,omitempty"`
	MaxNumConnectedUes     string         `protobuf:"bytes,10,opt,name=maxNumConnectedUes,proto3" json:"maxNumConnectedUes,omitempty"`
	MaxNumConnectedBearers string         `protobuf:"bytes,11,opt,name=maxNumConnectedBearers,proto3" json:"maxNumConnectedBearers,omitempty"`
	MaxNumUesSchedPerTtiDl string         `protobuf:"bytes,12,opt,name=maxNumUesSchedPerTtiDl,proto3" json:"maxNumUesSchedPerTtiDl,omitempty"`
	MaxNumUesSchedPerTtiUl string         `protobuf:"bytes,13,opt,name=maxNumUesSchedPerTtiUl,proto3" json:"maxNumUesSchedPerTtiUl,omitempty"`
	DlfsSchedEnable        string         `protobuf:"bytes,14,opt,name=dlfsSchedEnable,proto3" json:"dlfsSchedEnable,omitempty"`
}

func (m *C1CellConfigAttribute) Reset()         { *m = C1CellConfigAttribute{} }
func (m *C1CellConfigAttribute) String() string { return proto.CompactTextString(m) }
func (*C1CellConfigAttribute) ProtoMessage()    {}
func (*C1CellConfigAttribute) Descriptor() ([]byte, []int) {
	return fileDescriptor_49d6c0a03a213d51, []int{24}
}
func (m *C1CellConfigAttribute) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *C1CellConfigAttribute) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_C1CellConfigAttribute.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *C1CellConfigAttribute) XXX_Merge(src proto.Message) {
	xxx_messageInfo_C1CellConfigAttribute.Merge(m, src)
}
func (m *C1CellConfigAttribute) XXX_Size() int {
	return m.Size()
}
func (m *C1CellConfigAttribute) XXX_DiscardUnknown() {
	xxx_messageInfo_C1CellConfigAttribute.DiscardUnknown(m)
}

var xxx_messageInfo_C1CellConfigAttribute proto.InternalMessageInfo

func (m *C1CellConfigAttribute) GetEcgi() *C1ECGI {
	if m != nil {
		return m.Ecgi
	}
	return nil
}

func (m *C1CellConfigAttribute) GetPci() string {
	if m != nil {
		return m.Pci
	}
	return ""
}

func (m *C1CellConfigAttribute) GetCandScells() []*C1CandScell {
	if m != nil {
		return m.CandScells
	}
	return nil
}

func (m *C1CellConfigAttribute) GetEarfcnDl() string {
	if m != nil {
		return m.EarfcnDl
	}
	return ""
}

func (m *C1CellConfigAttribute) GetEarfcnUl() string {
	if m != nil {
		return m.EarfcnUl
	}
	return ""
}

func (m *C1CellConfigAttribute) GetRbsPerTtiDl() string {
	if m != nil {
		return m.RbsPerTtiDl
	}
	return ""
}

func (m *C1CellConfigAttribute) GetRbsPerTtiUl() string {
	if m != nil {
		return m.RbsPerTtiUl
	}
	return ""
}

func (m *C1CellConfigAttribute) GetNumTxAntenna() string {
	if m != nil {
		return m.NumTxAntenna
	}
	return ""
}

func (m *C1CellConfigAttribute) GetDuplexMode() string {
	if m != nil {
		return m.DuplexMode
	}
	return ""
}

func (m *C1CellConfigAttribute) GetMaxNumConnectedUes() string {
	if m != nil {
		return m.MaxNumConnectedUes
	}
	return ""
}

func (m *C1CellConfigAttribute) GetMaxNumConnectedBearers() string {
	if m != nil {
		return m.MaxNumConnectedBearers
	}
	return ""
}

func (m *C1CellConfigAttribute) GetMaxNumUesSchedPerTtiDl() string {
	if m != nil {
		return m.MaxNumUesSchedPerTtiDl
	}
	return ""
}

func (m *C1CellConfigAttribute) GetMaxNumUesSchedPerTtiUl() string {
	if m != nil {
		return m.MaxNumUesSchedPerTtiUl
	}
	return ""
}

func (m *C1CellConfigAttribute) GetDlfsSchedEnable() string {
	if m != nil {
		return m.DlfsSchedEnable
	}
	return ""
}

type C1PciArfcn struct {
	Pci      string `protobuf:"bytes,1,opt,name=pci,proto3" json:"pci,omitempty"`
	EarfcnDl string `protobuf:"bytes,2,opt,name=earfcnDl,proto3" json:"earfcnDl,omitempty"`
}

func (m *C1PciArfcn) Reset()         { *m = C1PciArfcn{} }
func (m *C1PciArfcn) String() string { return proto.CompactTextString(m) }
func (*C1PciArfcn) ProtoMessage()    {}
func (*C1PciArfcn) Descriptor() ([]byte, []int) {
	return fileDescriptor_49d6c0a03a213d51, []int{25}
}
func (m *C1PciArfcn) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *C1PciArfcn) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_C1PciArfcn.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *C1PciArfcn) XXX_Merge(src proto.Message) {
	xxx_messageInfo_C1PciArfcn.Merge(m, src)
}
func (m *C1PciArfcn) XXX_Size() int {
	return m.Size()
}
func (m *C1PciArfcn) XXX_DiscardUnknown() {
	xxx_messageInfo_C1PciArfcn.DiscardUnknown(m)
}

var xxx_messageInfo_C1PciArfcn proto.InternalMessageInfo

func (m *C1PciArfcn) GetPci() string {
	if m != nil {
		return m.Pci
	}
	return ""
}

func (m *C1PciArfcn) GetEarfcnDl() string {
	if m != nil {
		return m.EarfcnDl
	}
	return ""
}

// This attributed defined all elements as a list (repeated), but this list only has a single element for MWC demo -> will be extended
type C1RRMConfigAttribute struct {
	Ecgi              *C1ECGI     `protobuf:"bytes,1,opt,name=ecgi,proto3" json:"ecgi,omitempty"`
	Crnti             []string    `protobuf:"bytes,2,rep,name=crnti,proto3" json:"crnti,omitempty"`
	PciArfcn          *C1PciArfcn `protobuf:"bytes,3,opt,name=pciArfcn,proto3" json:"pciArfcn,omitempty"`
	Pa                []C1XICICPA `protobuf:"varint,4,rep,packed,name=pa,proto3,enum=interface.c1.C1XICICPA" json:"pa,omitempty"`
	StartPrbDl        []string    `protobuf:"bytes,5,rep,name=startPrbDl,proto3" json:"startPrbDl,omitempty"`
	EndPrbDl          []string    `protobuf:"bytes,6,rep,name=endPrbDl,proto3" json:"endPrbDl,omitempty"`
	SubFrameBitmaskDl []string    `protobuf:"bytes,7,rep,name=subFrameBitmaskDl,proto3" json:"subFrameBitmaskDl,omitempty"`
	P0UePusch         []string    `protobuf:"bytes,8,rep,name=p0UePusch,proto3" json:"p0UePusch,omitempty"`
	StartPrbUl        []string    `protobuf:"bytes,9,rep,name=startPrbUl,proto3" json:"startPrbUl,omitempty"`
	EndPrbUl          []string    `protobuf:"bytes,10,rep,name=endPrbUl,proto3" json:"endPrbUl,omitempty"`
	SubFrameBitmaskUl []string    `protobuf:"bytes,11,rep,name=subFrameBitmaskUl,proto3" json:"subFrameBitmaskUl,omitempty"`
}

func (m *C1RRMConfigAttribute) Reset()         { *m = C1RRMConfigAttribute{} }
func (m *C1RRMConfigAttribute) String() string { return proto.CompactTextString(m) }
func (*C1RRMConfigAttribute) ProtoMessage()    {}
func (*C1RRMConfigAttribute) Descriptor() ([]byte, []int) {
	return fileDescriptor_49d6c0a03a213d51, []int{26}
}
func (m *C1RRMConfigAttribute) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *C1RRMConfigAttribute) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_C1RRMConfigAttribute.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *C1RRMConfigAttribute) XXX_Merge(src proto.Message) {
	xxx_messageInfo_C1RRMConfigAttribute.Merge(m, src)
}
func (m *C1RRMConfigAttribute) XXX_Size() int {
	return m.Size()
}
func (m *C1RRMConfigAttribute) XXX_DiscardUnknown() {
	xxx_messageInfo_C1RRMConfigAttribute.DiscardUnknown(m)
}

var xxx_messageInfo_C1RRMConfigAttribute proto.InternalMessageInfo

func (m *C1RRMConfigAttribute) GetEcgi() *C1ECGI {
	if m != nil {
		return m.Ecgi
	}
	return nil
}

func (m *C1RRMConfigAttribute) GetCrnti() []string {
	if m != nil {
		return m.Crnti
	}
	return nil
}

func (m *C1RRMConfigAttribute) GetPciArfcn() *C1PciArfcn {
	if m != nil {
		return m.PciArfcn
	}
	return nil
}

func (m *C1RRMConfigAttribute) GetPa() []C1XICICPA {
	if m != nil {
		return m.Pa
	}
	return nil
}

func (m *C1RRMConfigAttribute) GetStartPrbDl() []string {
	if m != nil {
		return m.StartPrbDl
	}
	return nil
}

func (m *C1RRMConfigAttribute) GetEndPrbDl() []string {
	if m != nil {
		return m.EndPrbDl
	}
	return nil
}

func (m *C1RRMConfigAttribute) GetSubFrameBitmaskDl() []string {
	if m != nil {
		return m.SubFrameBitmaskDl
	}
	return nil
}

func (m *C1RRMConfigAttribute) GetP0UePusch() []string {
	if m != nil {
		return m.P0UePusch
	}
	return nil
}

func (m *C1RRMConfigAttribute) GetStartPrbUl() []string {
	if m != nil {
		return m.StartPrbUl
	}
	return nil
}

func (m *C1RRMConfigAttribute) GetEndPrbUl() []string {
	if m != nil {
		return m.EndPrbUl
	}
	return nil
}

func (m *C1RRMConfigAttribute) GetSubFrameBitmaskUl() []string {
	if m != nil {
		return m.SubFrameBitmaskUl
	}
	return nil
}

type C1RNIBUE struct {
	Imsi string `protobuf:"bytes,1,opt,name=imsi,proto3" json:"imsi,omitempty"`
	// attributes of R-NIB UE
	Crnti       string  `protobuf:"bytes,2,opt,name=crnti,proto3" json:"crnti,omitempty"`
	SCell       *C1ECGI `protobuf:"bytes,3,opt,name=sCell,proto3" json:"sCell,omitempty"`
	MmeUeS1ApId string  `protobuf:"bytes,4,opt,name=mmeUeS1apId,proto3" json:"mmeUeS1apId,omitempty"`
	EnbUeS1ApId string  `protobuf:"bytes,5,opt,name=enbUeS1apId,proto3" json:"enbUeS1apId,omitempty"`
}

func (m *C1RNIBUE) Reset()         { *m = C1RNIBUE{} }
func (m *C1RNIBUE) String() string { return proto.CompactTextString(m) }
func (*C1RNIBUE) ProtoMessage()    {}
func (*C1RNIBUE) Descriptor() ([]byte, []int) {
	return fileDescriptor_49d6c0a03a213d51, []int{27}
}
func (m *C1RNIBUE) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *C1RNIBUE) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_C1RNIBUE.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *C1RNIBUE) XXX_Merge(src proto.Message) {
	xxx_messageInfo_C1RNIBUE.Merge(m, src)
}
func (m *C1RNIBUE) XXX_Size() int {
	return m.Size()
}
func (m *C1RNIBUE) XXX_DiscardUnknown() {
	xxx_messageInfo_C1RNIBUE.DiscardUnknown(m)
}

var xxx_messageInfo_C1RNIBUE proto.InternalMessageInfo

func (m *C1RNIBUE) GetImsi() string {
	if m != nil {
		return m.Imsi
	}
	return ""
}

func (m *C1RNIBUE) GetCrnti() string {
	if m != nil {
		return m.Crnti
	}
	return ""
}

func (m *C1RNIBUE) GetSCell() *C1ECGI {
	if m != nil {
		return m.SCell
	}
	return nil
}

func (m *C1RNIBUE) GetMmeUeS1ApId() string {
	if m != nil {
		return m.MmeUeS1ApId
	}
	return ""
}

func (m *C1RNIBUE) GetEnbUeS1ApId() string {
	if m != nil {
		return m.EnbUeS1ApId
	}
	return ""
}

type C1RNIBLinkID struct {
	Ecgi *C1ECGI `protobuf:"bytes,1,opt,name=ecgi,proto3" json:"ecgi,omitempty"`
	Imsi string  `protobuf:"bytes,2,opt,name=imsi,proto3" json:"imsi,omitempty"`
}

func (m *C1RNIBLinkID) Reset()         { *m = C1RNIBLinkID{} }
func (m *C1RNIBLinkID) String() string { return proto.CompactTextString(m) }
func (*C1RNIBLinkID) ProtoMessage()    {}
func (*C1RNIBLinkID) Descriptor() ([]byte, []int) {
	return fileDescriptor_49d6c0a03a213d51, []int{28}
}
func (m *C1RNIBLinkID) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *C1RNIBLinkID) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_C1RNIBLinkID.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *C1RNIBLinkID) XXX_Merge(src proto.Message) {
	xxx_messageInfo_C1RNIBLinkID.Merge(m, src)
}
func (m *C1RNIBLinkID) XXX_Size() int {
	return m.Size()
}
func (m *C1RNIBLinkID) XXX_DiscardUnknown() {
	xxx_messageInfo_C1RNIBLinkID.DiscardUnknown(m)
}

var xxx_messageInfo_C1RNIBLinkID proto.InternalMessageInfo

func (m *C1RNIBLinkID) GetEcgi() *C1ECGI {
	if m != nil {
		return m.Ecgi
	}
	return nil
}

func (m *C1RNIBLinkID) GetImsi() string {
	if m != nil {
		return m.Imsi
	}
	return ""
}

// either serving cell or neighbor cell report
type C1RadioRepPerServCellAttribute struct {
	Ecgi          *C1ECGI  `protobuf:"bytes,1,opt,name=ecgi,proto3" json:"ecgi,omitempty"`
	CqiHist       []string `protobuf:"bytes,2,rep,name=cqiHist,proto3" json:"cqiHist,omitempty"`
	RiHist        []string `protobuf:"bytes,3,rep,name=riHist,proto3" json:"riHist,omitempty"`
	PuschSinrHist []string `protobuf:"bytes,4,rep,name=puschSinrHist,proto3" json:"puschSinrHist,omitempty"`
	PucchSinrHist []string `protobuf:"bytes,5,rep,name=pucchSinrHist,proto3" json:"pucchSinrHist,omitempty"`
}

func (m *C1RadioRepPerServCellAttribute) Reset()         { *m = C1RadioRepPerServCellAttribute{} }
func (m *C1RadioRepPerServCellAttribute) String() string { return proto.CompactTextString(m) }
func (*C1RadioRepPerServCellAttribute) ProtoMessage()    {}
func (*C1RadioRepPerServCellAttribute) Descriptor() ([]byte, []int) {
	return fileDescriptor_49d6c0a03a213d51, []int{29}
}
func (m *C1RadioRepPerServCellAttribute) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *C1RadioRepPerServCellAttribute) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_C1RadioRepPerServCellAttribute.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *C1RadioRepPerServCellAttribute) XXX_Merge(src proto.Message) {
	xxx_messageInfo_C1RadioRepPerServCellAttribute.Merge(m, src)
}
func (m *C1RadioRepPerServCellAttribute) XXX_Size() int {
	return m.Size()
}
func (m *C1RadioRepPerServCellAttribute) XXX_DiscardUnknown() {
	xxx_messageInfo_C1RadioRepPerServCellAttribute.DiscardUnknown(m)
}

var xxx_messageInfo_C1RadioRepPerServCellAttribute proto.InternalMessageInfo

func (m *C1RadioRepPerServCellAttribute) GetEcgi() *C1ECGI {
	if m != nil {
		return m.Ecgi
	}
	return nil
}

func (m *C1RadioRepPerServCellAttribute) GetCqiHist() []string {
	if m != nil {
		return m.CqiHist
	}
	return nil
}

func (m *C1RadioRepPerServCellAttribute) GetRiHist() []string {
	if m != nil {
		return m.RiHist
	}
	return nil
}

func (m *C1RadioRepPerServCellAttribute) GetPuschSinrHist() []string {
	if m != nil {
		return m.PuschSinrHist
	}
	return nil
}

func (m *C1RadioRepPerServCellAttribute) GetPucchSinrHist() []string {
	if m != nil {
		return m.PucchSinrHist
	}
	return nil
}

type C1RadioMeasReportPerUeAttribute struct {
	RadioRepPerServCell []*C1RadioRepPerServCellAttribute `protobuf:"bytes,1,rep,name=radioRepPerServCell,proto3" json:"radioRepPerServCell,omitempty"`
}

func (m *C1RadioMeasReportPerUeAttribute) Reset()         { *m = C1RadioMeasReportPerUeAttribute{} }
func (m *C1RadioMeasReportPerUeAttribute) String() string { return proto.CompactTextString(m) }
func (*C1RadioMeasReportPerUeAttribute) ProtoMessage()    {}
func (*C1RadioMeasReportPerUeAttribute) Descriptor() ([]byte, []int) {
	return fileDescriptor_49d6c0a03a213d51, []int{30}
}
func (m *C1RadioMeasReportPerUeAttribute) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *C1RadioMeasReportPerUeAttribute) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_C1RadioMeasReportPerUeAttribute.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *C1RadioMeasReportPerUeAttribute) XXX_Merge(src proto.Message) {
	xxx_messageInfo_C1RadioMeasReportPerUeAttribute.Merge(m, src)
}
func (m *C1RadioMeasReportPerUeAttribute) XXX_Size() int {
	return m.Size()
}
func (m *C1RadioMeasReportPerUeAttribute) XXX_DiscardUnknown() {
	xxx_messageInfo_C1RadioMeasReportPerUeAttribute.DiscardUnknown(m)
}

var xxx_messageInfo_C1RadioMeasReportPerUeAttribute proto.InternalMessageInfo

func (m *C1RadioMeasReportPerUeAttribute) GetRadioRepPerServCell() []*C1RadioRepPerServCellAttribute {
	if m != nil {
		return m.RadioRepPerServCell
	}
	return nil
}

type C1RNIBLink struct {
	LinkId *C1RNIBLinkID `protobuf:"bytes,1,opt,name=linkId,proto3" json:"linkId,omitempty"`
	// attributes of R-NIB Link
	RadioMeasReportPerUe *C1RadioMeasReportPerUeAttribute `protobuf:"bytes,2,opt,name=radioMeasReportPerUe,proto3" json:"radioMeasReportPerUe,omitempty"`
}

func (m *C1RNIBLink) Reset()         { *m = C1RNIBLink{} }
func (m *C1RNIBLink) String() string { return proto.CompactTextString(m) }
func (*C1RNIBLink) ProtoMessage()    {}
func (*C1RNIBLink) Descriptor() ([]byte, []int) {
	return fileDescriptor_49d6c0a03a213d51, []int{31}
}
func (m *C1RNIBLink) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *C1RNIBLink) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_C1RNIBLink.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *C1RNIBLink) XXX_Merge(src proto.Message) {
	xxx_messageInfo_C1RNIBLink.Merge(m, src)
}
func (m *C1RNIBLink) XXX_Size() int {
	return m.Size()
}
func (m *C1RNIBLink) XXX_DiscardUnknown() {
	xxx_messageInfo_C1RNIBLink.DiscardUnknown(m)
}

var xxx_messageInfo_C1RNIBLink proto.InternalMessageInfo

func (m *C1RNIBLink) GetLinkId() *C1RNIBLinkID {
	if m != nil {
		return m.LinkId
	}
	return nil
}

func (m *C1RNIBLink) GetRadioMeasReportPerUe() *C1RadioMeasReportPerUeAttribute {
	if m != nil {
		return m.RadioMeasReportPerUe
	}
	return nil
}

type C1HandoverRequest struct {
	// UE in links[index] should be moved from srcCells[index] to dstCell[index]
	Links    *C1RNIBLinks `protobuf:"bytes,1,opt,name=links,proto3" json:"links,omitempty"`
	SrcCells *C1RNIBCells `protobuf:"bytes,2,opt,name=srcCells,proto3" json:"srcCells,omitempty"`
	DstCells *C1RNIBCells `protobuf:"bytes,3,opt,name=dstCells,proto3" json:"dstCells,omitempty"`
}

func (m *C1HandoverRequest) Reset()         { *m = C1HandoverRequest{} }
func (m *C1HandoverRequest) String() string { return proto.CompactTextString(m) }
func (*C1HandoverRequest) ProtoMessage()    {}
func (*C1HandoverRequest) Descriptor() ([]byte, []int) {
	return fileDescriptor_49d6c0a03a213d51, []int{32}
}
func (m *C1HandoverRequest) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *C1HandoverRequest) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_C1HandoverRequest.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *C1HandoverRequest) XXX_Merge(src proto.Message) {
	xxx_messageInfo_C1HandoverRequest.Merge(m, src)
}
func (m *C1HandoverRequest) XXX_Size() int {
	return m.Size()
}
func (m *C1HandoverRequest) XXX_DiscardUnknown() {
	xxx_messageInfo_C1HandoverRequest.DiscardUnknown(m)
}

var xxx_messageInfo_C1HandoverRequest proto.InternalMessageInfo

func (m *C1HandoverRequest) GetLinks() *C1RNIBLinks {
	if m != nil {
		return m.Links
	}
	return nil
}

func (m *C1HandoverRequest) GetSrcCells() *C1RNIBCells {
	if m != nil {
		return m.SrcCells
	}
	return nil
}

func (m *C1HandoverRequest) GetDstCells() *C1RNIBCells {
	if m != nil {
		return m.DstCells
	}
	return nil
}

type C1RRMConfiguration struct {
	// targetCells[index] should have the offset pa which MLB app assigns; pa value in targetCell[index] is the new value to update on RNIBCell
	TargetCells *C1RNIBCells `protobuf:"bytes,1,opt,name=targetCells,proto3" json:"targetCells,omitempty"`
}

func (m *C1RRMConfiguration) Reset()         { *m = C1RRMConfiguration{} }
func (m *C1RRMConfiguration) String() string { return proto.CompactTextString(m) }
func (*C1RRMConfiguration) ProtoMessage()    {}
func (*C1RRMConfiguration) Descriptor() ([]byte, []int) {
	return fileDescriptor_49d6c0a03a213d51, []int{33}
}
func (m *C1RRMConfiguration) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *C1RRMConfiguration) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_C1RRMConfiguration.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *C1RRMConfiguration) XXX_Merge(src proto.Message) {
	xxx_messageInfo_C1RRMConfiguration.Merge(m, src)
}
func (m *C1RRMConfiguration) XXX_Size() int {
	return m.Size()
}
func (m *C1RRMConfiguration) XXX_DiscardUnknown() {
	xxx_messageInfo_C1RRMConfiguration.DiscardUnknown(m)
}

var xxx_messageInfo_C1RRMConfiguration proto.InternalMessageInfo

func (m *C1RRMConfiguration) GetTargetCells() *C1RNIBCells {
	if m != nil {
		return m.TargetCells
	}
	return nil
}

func init() {
	proto.RegisterEnum("interface.c1.StationPowerOffset", StationPowerOffset_name, StationPowerOffset_value)
	proto.RegisterEnum("interface.c1.C1MessageType", C1MessageType_name, C1MessageType_value)
	proto.RegisterEnum("interface.c1.C1RNIBType", C1RNIBType_name, C1RNIBType_value)
	proto.RegisterEnum("interface.c1.C1XICICPA", C1XICICPA_name, C1XICICPA_value)
	proto.RegisterType((*ECGI)(nil), "interface.c1.ECGI")
	proto.RegisterType((*StationListRequest)(nil), "interface.c1.StationListRequest")
	proto.RegisterType((*StationInfo)(nil), "interface.c1.StationInfo")
	proto.RegisterType((*StationLinkListRequest)(nil), "interface.c1.StationLinkListRequest")
	proto.RegisterType((*StationLinkInfo)(nil), "interface.c1.StationLinkInfo")
	proto.RegisterType((*UELinkListRequest)(nil), "interface.c1.UELinkListRequest")
	proto.RegisterType((*ChannelQuality)(nil), "interface.c1.ChannelQuality")
	proto.RegisterType((*UELinkInfo)(nil), "interface.c1.UELinkInfo")
	proto.RegisterType((*HandOverRequest)(nil), "interface.c1.HandOverRequest")
	proto.RegisterType((*HandOverResponse)(nil), "interface.c1.HandOverResponse")
	proto.RegisterType((*RadioPowerRequest)(nil), "interface.c1.RadioPowerRequest")
	proto.RegisterType((*RadioPowerResponse)(nil), "interface.c1.RadioPowerResponse")
	proto.RegisterType((*C1RequestMessage)(nil), "interface.c1.C1RequestMessage")
	proto.RegisterType((*C1ResponseMessage)(nil), "interface.c1.C1ResponseMessage")
	proto.RegisterType((*C1RequestMessageHeader)(nil), "interface.c1.C1RequestMessageHeader")
	proto.RegisterType((*C1RequestMessagePayload)(nil), "interface.c1.C1RequestMessagePayload")
	proto.RegisterType((*C1ResponseMessageHeader)(nil), "interface.c1.C1ResponseMessageHeader")
	proto.RegisterType((*C1ResponseMessagePayload)(nil), "interface.c1.C1ResponseMessagePayload")
	proto.RegisterType((*C1RNIBCells)(nil), "interface.c1.C1RNIBCells")
	proto.RegisterType((*C1RNIBUEs)(nil), "interface.c1.C1RNIBUEs")
	proto.RegisterType((*C1RNIBLinks)(nil), "interface.c1.C1RNIBLinks")
	proto.RegisterType((*C1ECGI)(nil), "interface.c1.C1ECGI")
	proto.RegisterType((*C1CandScell)(nil), "interface.c1.C1CandScell")
	proto.RegisterType((*C1RNIBCell)(nil), "interface.c1.C1RNIBCell")
	proto.RegisterType((*C1CellConfigAttribute)(nil), "interface.c1.C1CellConfigAttribute")
	proto.RegisterType((*C1PciArfcn)(nil), "interface.c1.C1PciArfcn")
	proto.RegisterType((*C1RRMConfigAttribute)(nil), "interface.c1.C1RRMConfigAttribute")
	proto.RegisterType((*C1RNIBUE)(nil), "interface.c1.C1RNIBUE")
	proto.RegisterType((*C1RNIBLinkID)(nil), "interface.c1.C1RNIBLinkID")
	proto.RegisterType((*C1RadioRepPerServCellAttribute)(nil), "interface.c1.C1RadioRepPerServCellAttribute")
	proto.RegisterType((*C1RadioMeasReportPerUeAttribute)(nil), "interface.c1.C1RadioMeasReportPerUeAttribute")
	proto.RegisterType((*C1RNIBLink)(nil), "interface.c1.C1RNIBLink")
	proto.RegisterType((*C1HandoverRequest)(nil), "interface.c1.C1HandoverRequest")
	proto.RegisterType((*C1RRMConfiguration)(nil), "interface.c1.C1RRMConfiguration")
}

func init() { proto.RegisterFile("api/nb/c1-interface.proto", fileDescriptor_49d6c0a03a213d51) }

var fileDescriptor_49d6c0a03a213d51 = []byte{
	// 1933 bytes of a gzipped FileDescriptorProto
	0x1f, 0x8b, 0x08, 0x00, 0x00, 0x00, 0x00, 0x00, 0x02, 0xff, 0xac, 0x58, 0x4f, 0x73, 0xdc, 0x48,
	0x15, 0x1f, 0xcd, 0x8c, 0xc7, 0xf6, 0xf3, 0x3f, 0xb9, 0x37, 0xeb, 0x28, 0x26, 0xcc, 0xba, 0x44,
	0x58, 0x52, 0xae, 0xac, 0x93, 0xb1, 0x43, 0x96, 0x65, 0xd9, 0x02, 0x7b, 0x3c, 0x9b, 0x99, 0x8d,
	0x3d, 0x9e, 0xf4, 0x58, 0xb0, 0x50, 0x54, 0xa6, 0x34, 0x52, 0xdb, 0x56, 0xad, 0x46, 0xa3, 0x48,
	0x9a, 0x25, 0x3e, 0x72, 0xe6, 0x00, 0x54, 0x71, 0x81, 0xe2, 0x06, 0x55, 0x70, 0xa4, 0xf8, 0x14,
	0x7b, 0xcc, 0x91, 0xbd, 0x51, 0xc9, 0x67, 0xe0, 0x4e, 0x75, 0xab, 0x25, 0xb5, 0xfe, 0x39, 0x31,
	0xec, 0x4d, 0xfd, 0xde, 0xef, 0xbd, 0xfe, 0xbd, 0xf7, 0x5a, 0xdd, 0xaf, 0x1b, 0x6e, 0xe9, 0xae,
	0x75, 0xdf, 0x19, 0xdf, 0x37, 0x5a, 0x1f, 0x58, 0x4e, 0x40, 0xbc, 0x33, 0xdd, 0x20, 0x3b, 0xae,
	0x37, 0x0d, 0xa6, 0x68, 0x39, 0x11, 0x18, 0x2d, 0x75, 0x17, 0xea, 0x9d, 0xf6, 0xe3, 0x1e, 0xda,
	0x80, 0x86, 0x6b, 0x4f, 0x1c, 0xcb, 0x54, 0xa4, 0x2d, 0xe9, 0xee, 0x22, 0xe6, 0x23, 0x84, 0xa0,
	0x4e, 0x0c, 0xcb, 0x54, 0xaa, 0x4c, 0xca, 0xbe, 0xd5, 0x5f, 0x00, 0x1a, 0x06, 0x7a, 0x60, 0x4d,
	0x9d, 0x23, 0xcb, 0x0f, 0x30, 0x79, 0x3e, 0x23, 0x7e, 0x80, 0xde, 0xa7, 0xc8, 0x73, 0x8b, 0xd9,
	0x2f, 0xed, 0xa2, 0x1d, 0x71, 0x9a, 0x1d, 0x3a, 0x07, 0x66, 0x7a, 0x74, 0x1b, 0x16, 0xfd, 0xd9,
	0xd8, 0x37, 0x3c, 0x6b, 0x4c, 0x98, 0xdb, 0x05, 0x9c, 0x08, 0x54, 0x02, 0x4b, 0xdc, 0x77, 0xcf,
	0x39, 0x9b, 0xbe, 0xb5, 0xd3, 0x1d, 0x40, 0x13, 0xfd, 0x45, 0x7f, 0x36, 0x69, 0x4f, 0x1d, 0x87,
	0x18, 0x01, 0x31, 0x35, 0xe2, 0x2b, 0xb5, 0x2d, 0xe9, 0xee, 0x0a, 0x2e, 0xd0, 0xa8, 0xcf, 0x60,
	0x23, 0x0e, 0xc1, 0xf9, 0xe2, 0x9b, 0x0f, 0xe3, 0x39, 0xac, 0x09, 0xfe, 0xaf, 0x15, 0xca, 0x23,
	0x58, 0x76, 0x88, 0x75, 0x7e, 0x31, 0x9e, 0x7a, 0x54, 0xaa, 0x54, 0xb7, 0x6a, 0x25, 0xf8, 0x14,
	0x4e, 0xfd, 0x8d, 0x04, 0xeb, 0x5a, 0x27, 0x1b, 0xce, 0x0d, 0x98, 0x33, 0x3c, 0x27, 0xb0, 0x78,
	0x59, 0xc3, 0x41, 0xcc, 0xa5, 0x7a, 0x9d, 0x20, 0x6b, 0x99, 0x20, 0xd1, 0x26, 0x2c, 0x38, 0x53,
	0x4c, 0x5c, 0x5b, 0xbf, 0x54, 0xea, 0x4c, 0x19, 0x8f, 0xd5, 0x67, 0xb0, 0xda, 0xbe, 0xd0, 0x1d,
	0x87, 0xd8, 0x4f, 0x67, 0xba, 0x6d, 0x05, 0x97, 0x68, 0x17, 0x20, 0xd0, 0xbd, 0x73, 0x12, 0x74,
	0xae, 0xce, 0x82, 0x80, 0x42, 0x0a, 0xcc, 0x1b, 0xcf, 0xad, 0xae, 0xe5, 0x07, 0x8c, 0xea, 0x0a,
	0x8e, 0x86, 0xea, 0xdf, 0x25, 0x80, 0x30, 0x5a, 0x96, 0xdc, 0xff, 0x2f, 0xcc, 0x2e, 0xc8, 0x86,
	0x48, 0xd6, 0x62, 0x6b, 0x87, 0xa6, 0xfd, 0x76, 0xda, 0x26, 0x1d, 0x12, 0xce, 0x59, 0xd1, 0xdf,
	0xc5, 0x9a, 0xf8, 0x16, 0x4b, 0xc7, 0x22, 0x66, 0xdf, 0xea, 0x6f, 0x25, 0x58, 0xeb, 0xea, 0x8e,
	0x79, 0xf2, 0x25, 0xf1, 0xae, 0x2e, 0xcb, 0x2e, 0x80, 0xef, 0x19, 0x7c, 0xe1, 0x5c, 0xc1, 0x5a,
	0x40, 0x51, 0x1b, 0xd3, 0x0f, 0x22, 0x9b, 0x5a, 0xb9, 0x4d, 0x82, 0x52, 0xef, 0x81, 0x9c, 0x10,
	0xf2, 0xdd, 0xa9, 0xe3, 0x13, 0x9a, 0x6a, 0x7f, 0x66, 0x18, 0xc4, 0xf7, 0x19, 0xa7, 0x05, 0x1c,
	0x0d, 0xd5, 0x19, 0xac, 0x63, 0xdd, 0xb4, 0xa6, 0x83, 0xe9, 0xaf, 0x92, 0x00, 0xde, 0x76, 0x35,
	0xff, 0x00, 0x1a, 0xd3, 0xb3, 0x33, 0x9f, 0x84, 0x05, 0x5c, 0xdd, 0xdd, 0x4a, 0x23, 0x39, 0x23,
	0xe6, 0xfa, 0x84, 0xe1, 0x30, 0xc7, 0xab, 0x3b, 0x80, 0xc4, 0x69, 0xdf, 0x48, 0xf3, 0xf7, 0x12,
	0xc8, 0xed, 0x16, 0xe7, 0x77, 0x4c, 0x7c, 0x5f, 0x3f, 0x27, 0xe8, 0x47, 0xd0, 0xb8, 0x20, 0xba,
	0x49, 0x3c, 0x4e, 0xf4, 0x4e, 0xa6, 0x9e, 0x19, 0x7c, 0x97, 0x61, 0x31, 0xb7, 0x41, 0x3f, 0x86,
	0x79, 0x57, 0xbf, 0xb4, 0xa7, 0xba, 0xc9, 0x8b, 0xf1, 0xdd, 0xab, 0xcd, 0x07, 0x21, 0x18, 0x47,
	0x56, 0xea, 0x1f, 0x24, 0x58, 0xa7, 0xa0, 0x90, 0x7c, 0x44, 0xea, 0x93, 0x0c, 0xa9, 0x02, 0xaf,
	0x29, 0x83, 0x0c, 0xab, 0x9f, 0x64, 0x59, 0xbd, 0xff, 0x06, 0xfb, 0x1c, 0xad, 0x1e, 0x6c, 0x14,
	0x47, 0x8e, 0xee, 0x43, 0x3d, 0xb8, 0x74, 0x09, 0x23, 0xb6, 0xba, 0xfb, 0xad, 0xac, 0x63, 0x0e,
	0x3e, 0xbd, 0x74, 0x09, 0x66, 0x40, 0xf5, 0x8f, 0x55, 0xb8, 0x59, 0x92, 0x06, 0xd4, 0x85, 0x75,
	0x2f, 0x54, 0x10, 0x13, 0xf7, 0x7b, 0x07, 0xa7, 0x89, 0x67, 0x25, 0x47, 0x99, 0xeb, 0xbb, 0x15,
	0x9c, 0x37, 0x42, 0x4f, 0x60, 0xed, 0x42, 0x77, 0xcc, 0x69, 0xf2, 0x07, 0xf1, 0xd0, 0xdf, 0xcb,
	0xfa, 0xe9, 0xa6, 0x61, 0xdd, 0x0a, 0xce, 0x5a, 0xa2, 0x5f, 0xc2, 0x4d, 0xcf, 0xa3, 0xc7, 0xc1,
	0x99, 0x75, 0x3e, 0xf3, 0xd8, 0xfa, 0x8b, 0x9c, 0x86, 0xbf, 0xcf, 0x56, 0x8e, 0x1c, 0x3e, 0x4e,
	0xc1, 0xbb, 0x15, 0x5c, 0xe6, 0xe2, 0x60, 0x11, 0xe6, 0x39, 0x7f, 0xf5, 0xb3, 0x30, 0x35, 0x05,
	0xb5, 0xbc, 0x7e, 0x9e, 0xff, 0x23, 0x81, 0x52, 0x56, 0x58, 0x74, 0x07, 0x96, 0x3d, 0xae, 0x69,
	0x4f, 0xcd, 0xd0, 0xeb, 0x62, 0xb7, 0x82, 0x53, 0x52, 0xf4, 0x11, 0x2c, 0x7a, 0xfd, 0xde, 0x41,
	0x9b, 0xd8, 0xb6, 0xcf, 0xd3, 0x77, 0xab, 0xa8, 0x0c, 0x0c, 0xd0, 0xad, 0xe0, 0x04, 0x8d, 0xf6,
	0x60, 0x9e, 0x0e, 0xb4, 0x8e, 0xcf, 0x53, 0x74, 0xb3, 0xc8, 0x50, 0xeb, 0x50, 0xb3, 0x08, 0x19,
	0xcd, 0x47, 0xf7, 0x68, 0x9f, 0x6d, 0x88, 0x25, 0xf3, 0x31, 0x40, 0x34, 0x1f, 0x1b, 0x1c, 0x2c,
	0x40, 0xc3, 0x23, 0xfe, 0xcc, 0x0e, 0xd4, 0x0e, 0x2c, 0x09, 0xac, 0xd0, 0x23, 0x31, 0x06, 0x89,
	0x6d, 0xd1, 0x4a, 0x59, 0x0c, 0x42, 0x00, 0xea, 0x27, 0xb0, 0x18, 0x73, 0x44, 0x0f, 0x92, 0x68,
	0x42, 0x17, 0x1b, 0xc5, 0xd1, 0xc4, 0xa1, 0x24, 0x2c, 0x18, 0xbd, 0x88, 0x45, 0x18, 0xd9, 0x15,
	0x2c, 0x28, 0x40, 0x08, 0x4b, 0x7d, 0x08, 0x8d, 0x76, 0x4b, 0x6c, 0xb7, 0x7a, 0xa9, 0x76, 0xab,
	0x57, 0xdc, 0x6e, 0x7d, 0x4c, 0x27, 0x6f, 0xeb, 0x8e, 0x39, 0x34, 0x88, 0x6d, 0x23, 0x19, 0x6a,
	0xae, 0x11, 0x1d, 0x1c, 0xf4, 0x93, 0x9e, 0xc3, 0x44, 0xf7, 0xce, 0x0c, 0xe7, 0xd0, 0xe6, 0x86,
	0xf1, 0x58, 0xfd, 0x5a, 0x02, 0x48, 0x52, 0x82, 0xee, 0xa6, 0xb6, 0xed, 0x1b, 0x59, 0xd2, 0xc2,
	0xc6, 0xfd, 0x14, 0xd6, 0xe9, 0x74, 0xa9, 0x35, 0xce, 0x57, 0xcd, 0x77, 0xb2, 0x66, 0xed, 0x18,
	0xb8, 0x1f, 0x04, 0x9e, 0x35, 0x9e, 0x05, 0x04, 0xe7, 0xad, 0x51, 0x1f, 0xe4, 0xec, 0x5f, 0xc3,
	0x97, 0x93, 0x5a, 0xfa, 0xc7, 0x25, 0x0e, 0x73, 0xb6, 0xea, 0xcb, 0x3a, 0xbc, 0x5b, 0x38, 0xf9,
	0x35, 0xc2, 0xe4, 0xd9, 0xac, 0x26, 0xd9, 0xfc, 0x08, 0xc0, 0x88, 0x92, 0x1d, 0xb5, 0x01, 0xb9,
	0x75, 0x1b, 0x97, 0x03, 0x0b, 0xe0, 0x54, 0x21, 0xea, 0xe9, 0x42, 0x24, 0x3a, 0xcd, 0x56, 0xe6,
	0x44, 0x9d, 0x66, 0xa3, 0x2d, 0x58, 0xf2, 0xc6, 0xfe, 0x80, 0x78, 0xa7, 0x81, 0x75, 0x68, 0x2b,
	0x0d, 0xa6, 0x16, 0x45, 0x29, 0x84, 0x66, 0x2b, 0xf3, 0x19, 0x84, 0x66, 0x23, 0x15, 0x96, 0x9d,
	0xd9, 0xe4, 0xf4, 0xc5, 0xbe, 0x13, 0x10, 0xc7, 0xd1, 0x95, 0x05, 0x06, 0x49, 0xc9, 0x50, 0x13,
	0xc0, 0x9c, 0xb9, 0x36, 0x79, 0x71, 0x4c, 0x77, 0x89, 0x45, 0x86, 0x10, 0x24, 0x25, 0x5d, 0x34,
	0x30, 0x5c, 0x81, 0x06, 0x3d, 0x82, 0x8d, 0x8c, 0xf4, 0x80, 0xe8, 0x1e, 0xf1, 0x7c, 0x65, 0x89,
	0xd9, 0x94, 0x68, 0x13, 0x3b, 0x8d, 0xf8, 0x43, 0xe3, 0x82, 0x98, 0x71, 0xe8, 0xcb, 0xa2, 0x5d,
	0x56, 0x5b, 0x66, 0xa7, 0xd9, 0xca, 0x4a, 0xb9, 0x9d, 0x46, 0x57, 0xfd, 0x9a, 0x69, 0x9f, 0x85,
	0xc2, 0x8e, 0xa3, 0x8f, 0x6d, 0xa2, 0xac, 0x32, 0x83, 0xac, 0x58, 0xfd, 0x21, 0xfd, 0x5b, 0x06,
	0x86, 0xb5, 0x4f, 0x2b, 0x73, 0xcd, 0x5f, 0xed, 0x6f, 0x35, 0xb8, 0x51, 0xb4, 0x72, 0xaf, 0xb1,
	0x1a, 0xe3, 0xb6, 0x90, 0x36, 0xfd, 0x71, 0x5b, 0xf8, 0x10, 0x16, 0x5c, 0x4e, 0x89, 0xff, 0x2f,
	0xb9, 0xdd, 0x26, 0xa2, 0x8c, 0x63, 0x24, 0xfa, 0x1e, 0x54, 0x5d, 0x5d, 0xa9, 0x6f, 0xd5, 0xee,
	0xae, 0xe6, 0xb7, 0xeb, 0xcf, 0x7b, 0xed, 0x5e, 0x7b, 0xb0, 0x8f, 0xab, 0x2e, 0x5b, 0x15, 0x7e,
	0xa0, 0x7b, 0xc1, 0xc0, 0x1b, 0x1f, 0xd2, 0xb5, 0x49, 0x67, 0x16, 0x24, 0x2c, 0x66, 0xc7, 0x0c,
	0xb5, 0x0d, 0xa6, 0x8d, 0xc7, 0xe8, 0x1e, 0xac, 0xfb, 0xb3, 0xf1, 0xa7, 0x9e, 0x3e, 0x21, 0x07,
	0x56, 0x30, 0xd1, 0xfd, 0x2f, 0x0e, 0xe9, 0xea, 0xa4, 0xa0, 0xbc, 0x82, 0x5e, 0x27, 0xdc, 0x07,
	0x1a, 0x19, 0xcc, 0x7c, 0xe3, 0x42, 0x59, 0x60, 0xa8, 0x44, 0x20, 0xf2, 0xd0, 0x6c, 0x65, 0x31,
	0xcd, 0x43, 0x13, 0x78, 0x68, 0xb6, 0x02, 0x22, 0x0f, 0xad, 0x88, 0x87, 0x66, 0x2b, 0x4b, 0x85,
	0x3c, 0x34, 0x5b, 0xfd, 0xab, 0x04, 0x0b, 0xd1, 0x26, 0x1f, 0xb7, 0xec, 0x52, 0xd2, 0xb2, 0x8b,
	0x75, 0x10, 0xda, 0xf3, 0x6d, 0x98, 0xf3, 0xe9, 0x6e, 0xc3, 0x8b, 0x50, 0x5c, 0xc8, 0x10, 0x42,
	0x7f, 0xd8, 0xc9, 0x84, 0x68, 0x64, 0xd8, 0xd2, 0xdd, 0x9e, 0xc9, 0x77, 0x03, 0x51, 0x44, 0x11,
	0xc4, 0x19, 0xc7, 0x88, 0x70, 0x4f, 0x10, 0x45, 0xea, 0x11, 0x2c, 0x27, 0xe7, 0x48, 0xef, 0xf0,
	0x1a, 0xeb, 0x28, 0x8a, 0xa9, 0x2a, 0x5c, 0x43, 0xbe, 0x92, 0xa0, 0xd9, 0x6e, 0xb1, 0x96, 0x1a,
	0x13, 0x77, 0x40, 0xbc, 0x21, 0xf1, 0xbe, 0xa4, 0x5c, 0xff, 0x97, 0x85, 0x9a, 0xba, 0x98, 0xd1,
	0x2c, 0x47, 0x43, 0x7a, 0xb2, 0x79, 0xa1, 0xa2, 0xc6, 0x14, 0x7c, 0x84, 0xee, 0xc0, 0x8a, 0x4b,
	0xcb, 0x3c, 0xb4, 0x1c, 0x8f, 0xa9, 0xeb, 0x4c, 0x9d, 0x16, 0x86, 0x28, 0x43, 0x40, 0xcd, 0x45,
	0x28, 0x41, 0xa8, 0xfe, 0x5a, 0x82, 0xf7, 0x78, 0x28, 0xc7, 0x44, 0xf7, 0x31, 0x71, 0xa7, 0x5e,
	0x30, 0x20, 0x9e, 0x46, 0x92, 0x58, 0x9e, 0xc1, 0x3b, 0x5e, 0x3e, 0x56, 0x7e, 0x5a, 0xdf, 0xcb,
	0x9d, 0x37, 0x57, 0xa4, 0x05, 0x17, 0x39, 0x52, 0xff, 0x12, 0x1f, 0xac, 0xb4, 0x3a, 0x68, 0x17,
	0x1a, 0x36, 0xad, 0x92, 0xc9, 0x93, 0xb7, 0x59, 0xd6, 0x0f, 0xf4, 0x0e, 0x31, 0x47, 0x22, 0x1d,
	0x6e, 0x78, 0x05, 0x31, 0xf0, 0x53, 0xf6, 0x83, 0x42, 0x8e, 0x65, 0xf1, 0xe2, 0x42, 0x57, 0xea,
	0x3f, 0xd9, 0x05, 0x24, 0xd3, 0x14, 0xa3, 0xfb, 0x30, 0x67, 0xf3, 0xde, 0xe5, 0xea, 0xae, 0x0c,
	0x87, 0x38, 0xf4, 0x7d, 0x58, 0xf0, 0x3d, 0xe3, 0xed, 0x3a, 0x47, 0x1c, 0x43, 0xa9, 0x99, 0xe9,
	0x07, 0x6d, 0x7e, 0x90, 0xbe, 0xc9, 0x2c, 0x82, 0xaa, 0x4f, 0x01, 0xe5, 0x7b, 0x6e, 0xf4, 0x31,
	0x2c, 0x85, 0x2f, 0x03, 0x51, 0xf3, 0xf7, 0x06, 0x7f, 0x22, 0x7a, 0xfb, 0x4f, 0x52, 0xfc, 0x66,
	0x25, 0xdc, 0x35, 0x91, 0x0c, 0xcb, 0x83, 0xfd, 0xd1, 0xe1, 0xc1, 0xe8, 0xb8, 0xd7, 0xd7, 0x86,
	0x8f, 0xe4, 0x0a, 0x7a, 0x17, 0xd6, 0x13, 0xc9, 0xe7, 0x0f, 0x0f, 0x4f, 0x4e, 0x3f, 0xfc, 0x50,
	0x96, 0x32, 0xc0, 0x3d, 0xb9, 0x9a, 0x06, 0x0e, 0x5b, 0x21, 0xb0, 0x86, 0x96, 0x60, 0x3e, 0x14,
	0x3f, 0x90, 0xeb, 0xc9, 0xa0, 0x25, 0xcf, 0x25, 0x83, 0x5d, 0xb9, 0x91, 0x0c, 0xf6, 0xe4, 0xf9,
	0xed, 0x3f, 0x4b, 0xb0, 0x92, 0xea, 0xf9, 0xd1, 0x06, 0xcd, 0xc0, 0xe8, 0xb8, 0x33, 0x1c, 0xee,
	0x3f, 0xee, 0x8c, 0xb4, 0xfe, 0x93, 0xfe, 0xc9, 0xcf, 0xfa, 0x72, 0x05, 0xdd, 0xa0, 0x57, 0xdc,
	0xd1, 0xe3, 0xce, 0xe9, 0x88, 0xc5, 0xd9, 0x39, 0x3a, 0x1a, 0xca, 0x12, 0x42, 0xb0, 0x2a, 0x48,
	0xb5, 0xce, 0x50, 0xae, 0x66, 0x90, 0x47, 0xbd, 0xfe, 0x93, 0xa1, 0x5c, 0xa3, 0xa4, 0xdb, 0xad,
	0xd1, 0xe0, 0x64, 0x78, 0x3a, 0xea, 0xee, 0xf7, 0x0f, 0x4f, 0x7e, 0xda, 0xc1, 0x43, 0xb9, 0x8e,
	0x6e, 0xd3, 0xbb, 0x45, 0x28, 0xc6, 0xc7, 0xc7, 0xed, 0x93, 0xfe, 0xa7, 0xbd, 0xc7, 0x1a, 0xde,
	0x3f, 0xed, 0x9d, 0xf4, 0xe5, 0xb9, 0x6d, 0x2d, 0x5a, 0xe8, 0x8c, 0xda, 0x3b, 0xb0, 0xd6, 0x6e,
	0x31, 0xa7, 0x02, 0x2f, 0x99, 0xee, 0x54, 0xa1, 0x90, 0x92, 0x92, 0x25, 0xb4, 0x4a, 0x8d, 0x38,
	0xac, 0x23, 0x57, 0x45, 0x04, 0x25, 0x23, 0xd7, 0xb6, 0xbf, 0x96, 0x68, 0x4f, 0xce, 0x0f, 0x22,
	0x74, 0x8b, 0xb6, 0x72, 0x23, 0x36, 0x1a, 0x65, 0x4a, 0xd2, 0x84, 0xcd, 0x02, 0x55, 0x52, 0x9b,
	0x12, 0x53, 0x5a, 0xa4, 0x62, 0xd3, 0xa4, 0x5a, 0x61, 0x96, 0x44, 0x3d, 0x2d, 0x5b, 0x5e, 0x4a,
	0xeb, 0x97, 0x97, 0xd2, 0x42, 0xe6, 0xa5, 0x7b, 0xf2, 0xfc, 0xee, 0x3f, 0x6a, 0xb4, 0x80, 0xbd,
	0x68, 0x69, 0xd2, 0x4d, 0xc3, 0x32, 0x08, 0x3a, 0x86, 0xe5, 0x23, 0x2b, 0x7e, 0x86, 0xf1, 0x51,
	0xf1, 0x63, 0x88, 0xf0, 0x7c, 0xb7, 0x79, 0xab, 0x10, 0xd1, 0x73, 0xce, 0xa6, 0x0f, 0x24, 0xf4,
	0x73, 0x90, 0x05, 0x77, 0xe1, 0xd5, 0xe4, 0x4e, 0x89, 0xcb, 0xd4, 0xab, 0xe0, 0xe6, 0xb7, 0x4b,
	0x51, 0xdc, 0xf5, 0x67, 0xb0, 0x44, 0xf1, 0xe1, 0x0b, 0x9b, 0x8f, 0x32, 0xd7, 0xec, 0xdc, 0x33,
	0xe3, 0xa6, 0x52, 0x04, 0xe0, 0xbe, 0x06, 0xb0, 0x76, 0xea, 0x59, 0xe7, 0xe7, 0xc4, 0x8b, 0x1e,
	0x9d, 0x50, 0x66, 0xfe, 0xcc, 0xeb, 0xd8, 0x66, 0xb3, 0x4c, 0xcd, 0x1f, 0x81, 0x30, 0xac, 0x0c,
	0x49, 0x90, 0xbc, 0x0e, 0x65, 0xf9, 0xe5, 0x9e, 0xab, 0x36, 0xb7, 0xca, 0x01, 0xa1, 0xcf, 0x03,
	0xe5, 0xab, 0x57, 0x4d, 0xe9, 0xe5, 0xab, 0xa6, 0xf4, 0xef, 0x57, 0x4d, 0xe9, 0x77, 0xaf, 0x9b,
	0x95, 0x97, 0xaf, 0x9b, 0x95, 0x7f, 0xbd, 0x6e, 0x56, 0xc6, 0x0d, 0xf6, 0x6e, 0xbe, 0xf7, 0xdf,
	0x00, 0x00, 0x00, 0xff, 0xff, 0x70, 0xb3, 0x51, 0x27, 0x54, 0x17, 0x00, 0x00,
}

// Reference imports to suppress errors if they are not otherwise used.
var _ context.Context
var _ grpc.ClientConn

// This is a compile-time assertion to ensure that this generated file
// is compatible with the grpc package it is being compiled against.
const _ = grpc.SupportPackageIsVersion4

// C1InterfaceServiceClient is the client API for C1InterfaceService service.
//
// For semantics around ctx use and closing/ending streaming RPCs, please refer to https://godoc.org/google.golang.org/grpc#ClientConn.NewStream.
type C1InterfaceServiceClient interface {
	// ListStations returns a stream of base station records.
	ListStations(ctx context.Context, in *StationListRequest, opts ...grpc.CallOption) (C1InterfaceService_ListStationsClient, error)
	// ListStationLinks returns a stream of links between neighboring base stations.
	ListStationLinks(ctx context.Context, in *StationLinkListRequest, opts ...grpc.CallOption) (C1InterfaceService_ListStationLinksClient, error)
	// ListUELinks returns a stream of UI and base station links; one-time or (later) continuous subscribe.
	ListUELinks(ctx context.Context, in *UELinkListRequest, opts ...grpc.CallOption) (C1InterfaceService_ListUELinksClient, error)
	// TriggerHandOver returns a hand-over response indicating success or failure.
	// HO app will ask to handover to multiple UEs
	TriggerHandOver(ctx context.Context, in *HandOverRequest, opts ...grpc.CallOption) (*HandOverResponse, error)
	// SetRadioPower returns a response indicating success or failure.
	// MLB app will ask to change transmission power to multiple stations
	SetRadioPower(ctx context.Context, in *RadioPowerRequest, opts ...grpc.CallOption) (*RadioPowerResponse, error)
}

type c1InterfaceServiceClient struct {
	cc *grpc.ClientConn
}

func NewC1InterfaceServiceClient(cc *grpc.ClientConn) C1InterfaceServiceClient {
	return &c1InterfaceServiceClient{cc}
}

func (c *c1InterfaceServiceClient) ListStations(ctx context.Context, in *StationListRequest, opts ...grpc.CallOption) (C1InterfaceService_ListStationsClient, error) {
	stream, err := c.cc.NewStream(ctx, &_C1InterfaceService_serviceDesc.Streams[0], "/interface.c1.C1InterfaceService/ListStations", opts...)
	if err != nil {
		return nil, err
	}
	x := &c1InterfaceServiceListStationsClient{stream}
	if err := x.ClientStream.SendMsg(in); err != nil {
		return nil, err
	}
	if err := x.ClientStream.CloseSend(); err != nil {
		return nil, err
	}
	return x, nil
}

type C1InterfaceService_ListStationsClient interface {
	Recv() (*StationInfo, error)
	grpc.ClientStream
}

type c1InterfaceServiceListStationsClient struct {
	grpc.ClientStream
}

func (x *c1InterfaceServiceListStationsClient) Recv() (*StationInfo, error) {
	m := new(StationInfo)
	if err := x.ClientStream.RecvMsg(m); err != nil {
		return nil, err
	}
	return m, nil
}

func (c *c1InterfaceServiceClient) ListStationLinks(ctx context.Context, in *StationLinkListRequest, opts ...grpc.CallOption) (C1InterfaceService_ListStationLinksClient, error) {
	stream, err := c.cc.NewStream(ctx, &_C1InterfaceService_serviceDesc.Streams[1], "/interface.c1.C1InterfaceService/ListStationLinks", opts...)
	if err != nil {
		return nil, err
	}
	x := &c1InterfaceServiceListStationLinksClient{stream}
	if err := x.ClientStream.SendMsg(in); err != nil {
		return nil, err
	}
	if err := x.ClientStream.CloseSend(); err != nil {
		return nil, err
	}
	return x, nil
}

type C1InterfaceService_ListStationLinksClient interface {
	Recv() (*StationLinkInfo, error)
	grpc.ClientStream
}

type c1InterfaceServiceListStationLinksClient struct {
	grpc.ClientStream
}

func (x *c1InterfaceServiceListStationLinksClient) Recv() (*StationLinkInfo, error) {
	m := new(StationLinkInfo)
	if err := x.ClientStream.RecvMsg(m); err != nil {
		return nil, err
	}
	return m, nil
}

func (c *c1InterfaceServiceClient) ListUELinks(ctx context.Context, in *UELinkListRequest, opts ...grpc.CallOption) (C1InterfaceService_ListUELinksClient, error) {
	stream, err := c.cc.NewStream(ctx, &_C1InterfaceService_serviceDesc.Streams[2], "/interface.c1.C1InterfaceService/ListUELinks", opts...)
	if err != nil {
		return nil, err
	}
	x := &c1InterfaceServiceListUELinksClient{stream}
	if err := x.ClientStream.SendMsg(in); err != nil {
		return nil, err
	}
	if err := x.ClientStream.CloseSend(); err != nil {
		return nil, err
	}
	return x, nil
}

type C1InterfaceService_ListUELinksClient interface {
	Recv() (*UELinkInfo, error)
	grpc.ClientStream
}

type c1InterfaceServiceListUELinksClient struct {
	grpc.ClientStream
}

func (x *c1InterfaceServiceListUELinksClient) Recv() (*UELinkInfo, error) {
	m := new(UELinkInfo)
	if err := x.ClientStream.RecvMsg(m); err != nil {
		return nil, err
	}
	return m, nil
}

func (c *c1InterfaceServiceClient) TriggerHandOver(ctx context.Context, in *HandOverRequest, opts ...grpc.CallOption) (*HandOverResponse, error) {
	out := new(HandOverResponse)
	err := c.cc.Invoke(ctx, "/interface.c1.C1InterfaceService/TriggerHandOver", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *c1InterfaceServiceClient) SetRadioPower(ctx context.Context, in *RadioPowerRequest, opts ...grpc.CallOption) (*RadioPowerResponse, error) {
	out := new(RadioPowerResponse)
	err := c.cc.Invoke(ctx, "/interface.c1.C1InterfaceService/SetRadioPower", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

// C1InterfaceServiceServer is the server API for C1InterfaceService service.
type C1InterfaceServiceServer interface {
	// ListStations returns a stream of base station records.
	ListStations(*StationListRequest, C1InterfaceService_ListStationsServer) error
	// ListStationLinks returns a stream of links between neighboring base stations.
	ListStationLinks(*StationLinkListRequest, C1InterfaceService_ListStationLinksServer) error
	// ListUELinks returns a stream of UI and base station links; one-time or (later) continuous subscribe.
	ListUELinks(*UELinkListRequest, C1InterfaceService_ListUELinksServer) error
	// TriggerHandOver returns a hand-over response indicating success or failure.
	// HO app will ask to handover to multiple UEs
	TriggerHandOver(context.Context, *HandOverRequest) (*HandOverResponse, error)
	// SetRadioPower returns a response indicating success or failure.
	// MLB app will ask to change transmission power to multiple stations
	SetRadioPower(context.Context, *RadioPowerRequest) (*RadioPowerResponse, error)
}

// UnimplementedC1InterfaceServiceServer can be embedded to have forward compatible implementations.
type UnimplementedC1InterfaceServiceServer struct {
}

func (*UnimplementedC1InterfaceServiceServer) ListStations(req *StationListRequest, srv C1InterfaceService_ListStationsServer) error {
	return status.Errorf(codes.Unimplemented, "method ListStations not implemented")
}
func (*UnimplementedC1InterfaceServiceServer) ListStationLinks(req *StationLinkListRequest, srv C1InterfaceService_ListStationLinksServer) error {
	return status.Errorf(codes.Unimplemented, "method ListStationLinks not implemented")
}
func (*UnimplementedC1InterfaceServiceServer) ListUELinks(req *UELinkListRequest, srv C1InterfaceService_ListUELinksServer) error {
	return status.Errorf(codes.Unimplemented, "method ListUELinks not implemented")
}
func (*UnimplementedC1InterfaceServiceServer) TriggerHandOver(ctx context.Context, req *HandOverRequest) (*HandOverResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method TriggerHandOver not implemented")
}
func (*UnimplementedC1InterfaceServiceServer) SetRadioPower(ctx context.Context, req *RadioPowerRequest) (*RadioPowerResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method SetRadioPower not implemented")
}

func RegisterC1InterfaceServiceServer(s *grpc.Server, srv C1InterfaceServiceServer) {
	s.RegisterService(&_C1InterfaceService_serviceDesc, srv)
}

func _C1InterfaceService_ListStations_Handler(srv interface{}, stream grpc.ServerStream) error {
	m := new(StationListRequest)
	if err := stream.RecvMsg(m); err != nil {
		return err
	}
	return srv.(C1InterfaceServiceServer).ListStations(m, &c1InterfaceServiceListStationsServer{stream})
}

type C1InterfaceService_ListStationsServer interface {
	Send(*StationInfo) error
	grpc.ServerStream
}

type c1InterfaceServiceListStationsServer struct {
	grpc.ServerStream
}

func (x *c1InterfaceServiceListStationsServer) Send(m *StationInfo) error {
	return x.ServerStream.SendMsg(m)
}

func _C1InterfaceService_ListStationLinks_Handler(srv interface{}, stream grpc.ServerStream) error {
	m := new(StationLinkListRequest)
	if err := stream.RecvMsg(m); err != nil {
		return err
	}
	return srv.(C1InterfaceServiceServer).ListStationLinks(m, &c1InterfaceServiceListStationLinksServer{stream})
}

type C1InterfaceService_ListStationLinksServer interface {
	Send(*StationLinkInfo) error
	grpc.ServerStream
}

type c1InterfaceServiceListStationLinksServer struct {
	grpc.ServerStream
}

func (x *c1InterfaceServiceListStationLinksServer) Send(m *StationLinkInfo) error {
	return x.ServerStream.SendMsg(m)
}

func _C1InterfaceService_ListUELinks_Handler(srv interface{}, stream grpc.ServerStream) error {
	m := new(UELinkListRequest)
	if err := stream.RecvMsg(m); err != nil {
		return err
	}
	return srv.(C1InterfaceServiceServer).ListUELinks(m, &c1InterfaceServiceListUELinksServer{stream})
}

type C1InterfaceService_ListUELinksServer interface {
	Send(*UELinkInfo) error
	grpc.ServerStream
}

type c1InterfaceServiceListUELinksServer struct {
	grpc.ServerStream
}

func (x *c1InterfaceServiceListUELinksServer) Send(m *UELinkInfo) error {
	return x.ServerStream.SendMsg(m)
}

func _C1InterfaceService_TriggerHandOver_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(HandOverRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(C1InterfaceServiceServer).TriggerHandOver(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/interface.c1.C1InterfaceService/TriggerHandOver",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(C1InterfaceServiceServer).TriggerHandOver(ctx, req.(*HandOverRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _C1InterfaceService_SetRadioPower_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(RadioPowerRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(C1InterfaceServiceServer).SetRadioPower(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/interface.c1.C1InterfaceService/SetRadioPower",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(C1InterfaceServiceServer).SetRadioPower(ctx, req.(*RadioPowerRequest))
	}
	return interceptor(ctx, in, info, handler)
}

var _C1InterfaceService_serviceDesc = grpc.ServiceDesc{
	ServiceName: "interface.c1.C1InterfaceService",
	HandlerType: (*C1InterfaceServiceServer)(nil),
	Methods: []grpc.MethodDesc{
		{
			MethodName: "TriggerHandOver",
			Handler:    _C1InterfaceService_TriggerHandOver_Handler,
		},
		{
			MethodName: "SetRadioPower",
			Handler:    _C1InterfaceService_SetRadioPower_Handler,
		},
	},
	Streams: []grpc.StreamDesc{
		{
			StreamName:    "ListStations",
			Handler:       _C1InterfaceService_ListStations_Handler,
			ServerStreams: true,
		},
		{
			StreamName:    "ListStationLinks",
			Handler:       _C1InterfaceService_ListStationLinks_Handler,
			ServerStreams: true,
		},
		{
			StreamName:    "ListUELinks",
			Handler:       _C1InterfaceService_ListUELinks_Handler,
			ServerStreams: true,
		},
	},
	Metadata: "api/nb/c1-interface.proto",
}

func (m *ECGI) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *ECGI) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *ECGI) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.Ecid) > 0 {
		i -= len(m.Ecid)
		copy(dAtA[i:], m.Ecid)
		i = encodeVarintC1Interface(dAtA, i, uint64(len(m.Ecid)))
		i--
		dAtA[i] = 0x12
	}
	if len(m.Plmnid) > 0 {
		i -= len(m.Plmnid)
		copy(dAtA[i:], m.Plmnid)
		i = encodeVarintC1Interface(dAtA, i, uint64(len(m.Plmnid)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *StationListRequest) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *StationListRequest) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *StationListRequest) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.Subscribe {
		i--
		if m.Subscribe {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i--
		dAtA[i] = 0x10
	}
	if m.Ecgi != nil {
		{
			size, err := m.Ecgi.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintC1Interface(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *StationInfo) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *StationInfo) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *StationInfo) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.MaxNumConnectedUes != 0 {
		i = encodeVarintC1Interface(dAtA, i, uint64(m.MaxNumConnectedUes))
		i--
		dAtA[i] = 0x18
	}
	if m.Ecgi != nil {
		{
			size, err := m.Ecgi.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintC1Interface(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *StationLinkListRequest) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *StationLinkListRequest) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *StationLinkListRequest) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.Subscribe {
		i--
		if m.Subscribe {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i--
		dAtA[i] = 0x10
	}
	if m.Ecgi != nil {
		{
			size, err := m.Ecgi.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintC1Interface(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *StationLinkInfo) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *StationLinkInfo) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *StationLinkInfo) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.NeighborECGI) > 0 {
		for iNdEx := len(m.NeighborECGI) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.NeighborECGI[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintC1Interface(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x12
		}
	}
	if m.Ecgi != nil {
		{
			size, err := m.Ecgi.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintC1Interface(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *UELinkListRequest) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *UELinkListRequest) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *UELinkListRequest) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.NoReplay {
		i--
		if m.NoReplay {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i--
		dAtA[i] = 0x20
	}
	if m.Subscribe {
		i--
		if m.Subscribe {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i--
		dAtA[i] = 0x18
	}
	if m.Ecgi != nil {
		{
			size, err := m.Ecgi.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintC1Interface(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x12
	}
	if len(m.Crnti) > 0 {
		i -= len(m.Crnti)
		copy(dAtA[i:], m.Crnti)
		i = encodeVarintC1Interface(dAtA, i, uint64(len(m.Crnti)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *ChannelQuality) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *ChannelQuality) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *ChannelQuality) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.CqiHist != 0 {
		i = encodeVarintC1Interface(dAtA, i, uint64(m.CqiHist))
		i--
		dAtA[i] = 0x10
	}
	if m.TargetEcgi != nil {
		{
			size, err := m.TargetEcgi.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintC1Interface(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *UELinkInfo) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *UELinkInfo) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *UELinkInfo) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.Imsi) > 0 {
		i -= len(m.Imsi)
		copy(dAtA[i:], m.Imsi)
		i = encodeVarintC1Interface(dAtA, i, uint64(len(m.Imsi)))
		i--
		dAtA[i] = 0x22
	}
	if len(m.ChannelQualities) > 0 {
		for iNdEx := len(m.ChannelQualities) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.ChannelQualities[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintC1Interface(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x1a
		}
	}
	if m.Ecgi != nil {
		{
			size, err := m.Ecgi.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintC1Interface(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x12
	}
	if len(m.Crnti) > 0 {
		i -= len(m.Crnti)
		copy(dAtA[i:], m.Crnti)
		i = encodeVarintC1Interface(dAtA, i, uint64(len(m.Crnti)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *HandOverRequest) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *HandOverRequest) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *HandOverRequest) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.DstStation != nil {
		{
			size, err := m.DstStation.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintC1Interface(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x1a
	}
	if m.SrcStation != nil {
		{
			size, err := m.SrcStation.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintC1Interface(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x12
	}
	if len(m.Crnti) > 0 {
		i -= len(m.Crnti)
		copy(dAtA[i:], m.Crnti)
		i = encodeVarintC1Interface(dAtA, i, uint64(len(m.Crnti)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *HandOverResponse) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *HandOverResponse) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *HandOverResponse) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.Success {
		i--
		if m.Success {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *RadioPowerRequest) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *RadioPowerRequest) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *RadioPowerRequest) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.Offset != 0 {
		i = encodeVarintC1Interface(dAtA, i, uint64(m.Offset))
		i--
		dAtA[i] = 0x10
	}
	if m.Ecgi != nil {
		{
			size, err := m.Ecgi.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintC1Interface(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *RadioPowerResponse) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *RadioPowerResponse) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *RadioPowerResponse) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.Success {
		i--
		if m.Success {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *C1RequestMessage) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *C1RequestMessage) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *C1RequestMessage) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.Payload != nil {
		{
			size, err := m.Payload.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintC1Interface(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x12
	}
	if m.Header != nil {
		{
			size, err := m.Header.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintC1Interface(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *C1ResponseMessage) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *C1ResponseMessage) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *C1ResponseMessage) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.Payload != nil {
		{
			size, err := m.Payload.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintC1Interface(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x12
	}
	if m.Header != nil {
		{
			size, err := m.Header.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintC1Interface(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *C1RequestMessageHeader) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *C1RequestMessageHeader) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *C1RequestMessageHeader) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.Type != 0 {
		i = encodeVarintC1Interface(dAtA, i, uint64(m.Type))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *C1RequestMessagePayload) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *C1RequestMessagePayload) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *C1RequestMessagePayload) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.Request != nil {
		{
			size := m.Request.Size()
			i -= size
			if _, err := m.Request.MarshalTo(dAtA[i:]); err != nil {
				return 0, err
			}
		}
	}
	return len(dAtA) - i, nil
}

func (m *C1RequestMessagePayload_RequestedRNIBType) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *C1RequestMessagePayload_RequestedRNIBType) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	i = encodeVarintC1Interface(dAtA, i, uint64(m.RequestedRNIBType))
	i--
	dAtA[i] = 0x8
	return len(dAtA) - i, nil
}
func (m *C1RequestMessagePayload_HandoverRequest) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *C1RequestMessagePayload_HandoverRequest) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	if m.HandoverRequest != nil {
		{
			size, err := m.HandoverRequest.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintC1Interface(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x12
	}
	return len(dAtA) - i, nil
}
func (m *C1RequestMessagePayload_RrmConfigurationRequest) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *C1RequestMessagePayload_RrmConfigurationRequest) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	if m.RrmConfigurationRequest != nil {
		{
			size, err := m.RrmConfigurationRequest.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintC1Interface(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x1a
	}
	return len(dAtA) - i, nil
}
func (m *C1ResponseMessageHeader) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *C1ResponseMessageHeader) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *C1ResponseMessageHeader) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.Type != 0 {
		i = encodeVarintC1Interface(dAtA, i, uint64(m.Type))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *C1ResponseMessagePayload) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *C1ResponseMessagePayload) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *C1ResponseMessagePayload) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.Result != nil {
		{
			size := m.Result.Size()
			i -= size
			if _, err := m.Result.MarshalTo(dAtA[i:]); err != nil {
				return 0, err
			}
		}
	}
	return len(dAtA) - i, nil
}

func (m *C1ResponseMessagePayload_ResponseCode) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *C1ResponseMessagePayload_ResponseCode) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	i -= len(m.ResponseCode)
	copy(dAtA[i:], m.ResponseCode)
	i = encodeVarintC1Interface(dAtA, i, uint64(len(m.ResponseCode)))
	i--
	dAtA[i] = 0xa
	return len(dAtA) - i, nil
}
func (m *C1ResponseMessagePayload_RNIBCells) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *C1ResponseMessagePayload_RNIBCells) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	if m.RNIBCells != nil {
		{
			size, err := m.RNIBCells.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintC1Interface(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x12
	}
	return len(dAtA) - i, nil
}
func (m *C1ResponseMessagePayload_RNIBUEs) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *C1ResponseMessagePayload_RNIBUEs) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	if m.RNIBUEs != nil {
		{
			size, err := m.RNIBUEs.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintC1Interface(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x1a
	}
	return len(dAtA) - i, nil
}
func (m *C1ResponseMessagePayload_RNIBLinks) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *C1ResponseMessagePayload_RNIBLinks) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	if m.RNIBLinks != nil {
		{
			size, err := m.RNIBLinks.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintC1Interface(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x22
	}
	return len(dAtA) - i, nil
}
func (m *C1RNIBCells) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *C1RNIBCells) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *C1RNIBCells) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.RNIBCells) > 0 {
		for iNdEx := len(m.RNIBCells) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.RNIBCells[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintC1Interface(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0xa
		}
	}
	return len(dAtA) - i, nil
}

func (m *C1RNIBUEs) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *C1RNIBUEs) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *C1RNIBUEs) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.RNIBUEs) > 0 {
		for iNdEx := len(m.RNIBUEs) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.RNIBUEs[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintC1Interface(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0xa
		}
	}
	return len(dAtA) - i, nil
}

func (m *C1RNIBLinks) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *C1RNIBLinks) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *C1RNIBLinks) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.RNIBLinks) > 0 {
		for iNdEx := len(m.RNIBLinks) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.RNIBLinks[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintC1Interface(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0xa
		}
	}
	return len(dAtA) - i, nil
}

func (m *C1ECGI) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *C1ECGI) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *C1ECGI) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.Ecid) > 0 {
		i -= len(m.Ecid)
		copy(dAtA[i:], m.Ecid)
		i = encodeVarintC1Interface(dAtA, i, uint64(len(m.Ecid)))
		i--
		dAtA[i] = 0x12
	}
	if len(m.PlmnId) > 0 {
		i -= len(m.PlmnId)
		copy(dAtA[i:], m.PlmnId)
		i = encodeVarintC1Interface(dAtA, i, uint64(len(m.PlmnId)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *C1CandScell) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *C1CandScell) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *C1CandScell) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.EarfcnDl) > 0 {
		i -= len(m.EarfcnDl)
		copy(dAtA[i:], m.EarfcnDl)
		i = encodeVarintC1Interface(dAtA, i, uint64(len(m.EarfcnDl)))
		i--
		dAtA[i] = 0x12
	}
	if len(m.Pci) > 0 {
		i -= len(m.Pci)
		copy(dAtA[i:], m.Pci)
		i = encodeVarintC1Interface(dAtA, i, uint64(len(m.Pci)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *C1RNIBCell) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *C1RNIBCell) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *C1RNIBCell) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.RrmConfiguration != nil {
		{
			size, err := m.RrmConfiguration.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintC1Interface(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x1a
	}
	if m.CellConfiguration != nil {
		{
			size, err := m.CellConfiguration.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintC1Interface(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x12
	}
	if m.Ecgi != nil {
		{
			size, err := m.Ecgi.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintC1Interface(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *C1CellConfigAttribute) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *C1CellConfigAttribute) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *C1CellConfigAttribute) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.DlfsSchedEnable) > 0 {
		i -= len(m.DlfsSchedEnable)
		copy(dAtA[i:], m.DlfsSchedEnable)
		i = encodeVarintC1Interface(dAtA, i, uint64(len(m.DlfsSchedEnable)))
		i--
		dAtA[i] = 0x72
	}
	if len(m.MaxNumUesSchedPerTtiUl) > 0 {
		i -= len(m.MaxNumUesSchedPerTtiUl)
		copy(dAtA[i:], m.MaxNumUesSchedPerTtiUl)
		i = encodeVarintC1Interface(dAtA, i, uint64(len(m.MaxNumUesSchedPerTtiUl)))
		i--
		dAtA[i] = 0x6a
	}
	if len(m.MaxNumUesSchedPerTtiDl) > 0 {
		i -= len(m.MaxNumUesSchedPerTtiDl)
		copy(dAtA[i:], m.MaxNumUesSchedPerTtiDl)
		i = encodeVarintC1Interface(dAtA, i, uint64(len(m.MaxNumUesSchedPerTtiDl)))
		i--
		dAtA[i] = 0x62
	}
	if len(m.MaxNumConnectedBearers) > 0 {
		i -= len(m.MaxNumConnectedBearers)
		copy(dAtA[i:], m.MaxNumConnectedBearers)
		i = encodeVarintC1Interface(dAtA, i, uint64(len(m.MaxNumConnectedBearers)))
		i--
		dAtA[i] = 0x5a
	}
	if len(m.MaxNumConnectedUes) > 0 {
		i -= len(m.MaxNumConnectedUes)
		copy(dAtA[i:], m.MaxNumConnectedUes)
		i = encodeVarintC1Interface(dAtA, i, uint64(len(m.MaxNumConnectedUes)))
		i--
		dAtA[i] = 0x52
	}
	if len(m.DuplexMode) > 0 {
		i -= len(m.DuplexMode)
		copy(dAtA[i:], m.DuplexMode)
		i = encodeVarintC1Interface(dAtA, i, uint64(len(m.DuplexMode)))
		i--
		dAtA[i] = 0x4a
	}
	if len(m.NumTxAntenna) > 0 {
		i -= len(m.NumTxAntenna)
		copy(dAtA[i:], m.NumTxAntenna)
		i = encodeVarintC1Interface(dAtA, i, uint64(len(m.NumTxAntenna)))
		i--
		dAtA[i] = 0x42
	}
	if len(m.RbsPerTtiUl) > 0 {
		i -= len(m.RbsPerTtiUl)
		copy(dAtA[i:], m.RbsPerTtiUl)
		i = encodeVarintC1Interface(dAtA, i, uint64(len(m.RbsPerTtiUl)))
		i--
		dAtA[i] = 0x3a
	}
	if len(m.RbsPerTtiDl) > 0 {
		i -= len(m.RbsPerTtiDl)
		copy(dAtA[i:], m.RbsPerTtiDl)
		i = encodeVarintC1Interface(dAtA, i, uint64(len(m.RbsPerTtiDl)))
		i--
		dAtA[i] = 0x32
	}
	if len(m.EarfcnUl) > 0 {
		i -= len(m.EarfcnUl)
		copy(dAtA[i:], m.EarfcnUl)
		i = encodeVarintC1Interface(dAtA, i, uint64(len(m.EarfcnUl)))
		i--
		dAtA[i] = 0x2a
	}
	if len(m.EarfcnDl) > 0 {
		i -= len(m.EarfcnDl)
		copy(dAtA[i:], m.EarfcnDl)
		i = encodeVarintC1Interface(dAtA, i, uint64(len(m.EarfcnDl)))
		i--
		dAtA[i] = 0x22
	}
	if len(m.CandScells) > 0 {
		for iNdEx := len(m.CandScells) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.CandScells[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintC1Interface(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x1a
		}
	}
	if len(m.Pci) > 0 {
		i -= len(m.Pci)
		copy(dAtA[i:], m.Pci)
		i = encodeVarintC1Interface(dAtA, i, uint64(len(m.Pci)))
		i--
		dAtA[i] = 0x12
	}
	if m.Ecgi != nil {
		{
			size, err := m.Ecgi.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintC1Interface(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *C1PciArfcn) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *C1PciArfcn) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *C1PciArfcn) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.EarfcnDl) > 0 {
		i -= len(m.EarfcnDl)
		copy(dAtA[i:], m.EarfcnDl)
		i = encodeVarintC1Interface(dAtA, i, uint64(len(m.EarfcnDl)))
		i--
		dAtA[i] = 0x12
	}
	if len(m.Pci) > 0 {
		i -= len(m.Pci)
		copy(dAtA[i:], m.Pci)
		i = encodeVarintC1Interface(dAtA, i, uint64(len(m.Pci)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *C1RRMConfigAttribute) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *C1RRMConfigAttribute) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *C1RRMConfigAttribute) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.SubFrameBitmaskUl) > 0 {
		for iNdEx := len(m.SubFrameBitmaskUl) - 1; iNdEx >= 0; iNdEx-- {
			i -= len(m.SubFrameBitmaskUl[iNdEx])
			copy(dAtA[i:], m.SubFrameBitmaskUl[iNdEx])
			i = encodeVarintC1Interface(dAtA, i, uint64(len(m.SubFrameBitmaskUl[iNdEx])))
			i--
			dAtA[i] = 0x5a
		}
	}
	if len(m.EndPrbUl) > 0 {
		for iNdEx := len(m.EndPrbUl) - 1; iNdEx >= 0; iNdEx-- {
			i -= len(m.EndPrbUl[iNdEx])
			copy(dAtA[i:], m.EndPrbUl[iNdEx])
			i = encodeVarintC1Interface(dAtA, i, uint64(len(m.EndPrbUl[iNdEx])))
			i--
			dAtA[i] = 0x52
		}
	}
	if len(m.StartPrbUl) > 0 {
		for iNdEx := len(m.StartPrbUl) - 1; iNdEx >= 0; iNdEx-- {
			i -= len(m.StartPrbUl[iNdEx])
			copy(dAtA[i:], m.StartPrbUl[iNdEx])
			i = encodeVarintC1Interface(dAtA, i, uint64(len(m.StartPrbUl[iNdEx])))
			i--
			dAtA[i] = 0x4a
		}
	}
	if len(m.P0UePusch) > 0 {
		for iNdEx := len(m.P0UePusch) - 1; iNdEx >= 0; iNdEx-- {
			i -= len(m.P0UePusch[iNdEx])
			copy(dAtA[i:], m.P0UePusch[iNdEx])
			i = encodeVarintC1Interface(dAtA, i, uint64(len(m.P0UePusch[iNdEx])))
			i--
			dAtA[i] = 0x42
		}
	}
	if len(m.SubFrameBitmaskDl) > 0 {
		for iNdEx := len(m.SubFrameBitmaskDl) - 1; iNdEx >= 0; iNdEx-- {
			i -= len(m.SubFrameBitmaskDl[iNdEx])
			copy(dAtA[i:], m.SubFrameBitmaskDl[iNdEx])
			i = encodeVarintC1Interface(dAtA, i, uint64(len(m.SubFrameBitmaskDl[iNdEx])))
			i--
			dAtA[i] = 0x3a
		}
	}
	if len(m.EndPrbDl) > 0 {
		for iNdEx := len(m.EndPrbDl) - 1; iNdEx >= 0; iNdEx-- {
			i -= len(m.EndPrbDl[iNdEx])
			copy(dAtA[i:], m.EndPrbDl[iNdEx])
			i = encodeVarintC1Interface(dAtA, i, uint64(len(m.EndPrbDl[iNdEx])))
			i--
			dAtA[i] = 0x32
		}
	}
	if len(m.StartPrbDl) > 0 {
		for iNdEx := len(m.StartPrbDl) - 1; iNdEx >= 0; iNdEx-- {
			i -= len(m.StartPrbDl[iNdEx])
			copy(dAtA[i:], m.StartPrbDl[iNdEx])
			i = encodeVarintC1Interface(dAtA, i, uint64(len(m.StartPrbDl[iNdEx])))
			i--
			dAtA[i] = 0x2a
		}
	}
	if len(m.Pa) > 0 {
		dAtA25 := make([]byte, len(m.Pa)*10)
		var j24 int
		for _, num := range m.Pa {
			for num >= 1<<7 {
				dAtA25[j24] = uint8(uint64(num)&0x7f | 0x80)
				num >>= 7
				j24++
			}
			dAtA25[j24] = uint8(num)
			j24++
		}
		i -= j24
		copy(dAtA[i:], dAtA25[:j24])
		i = encodeVarintC1Interface(dAtA, i, uint64(j24))
		i--
		dAtA[i] = 0x22
	}
	if m.PciArfcn != nil {
		{
			size, err := m.PciArfcn.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintC1Interface(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x1a
	}
	if len(m.Crnti) > 0 {
		for iNdEx := len(m.Crnti) - 1; iNdEx >= 0; iNdEx-- {
			i -= len(m.Crnti[iNdEx])
			copy(dAtA[i:], m.Crnti[iNdEx])
			i = encodeVarintC1Interface(dAtA, i, uint64(len(m.Crnti[iNdEx])))
			i--
			dAtA[i] = 0x12
		}
	}
	if m.Ecgi != nil {
		{
			size, err := m.Ecgi.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintC1Interface(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *C1RNIBUE) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *C1RNIBUE) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *C1RNIBUE) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.EnbUeS1ApId) > 0 {
		i -= len(m.EnbUeS1ApId)
		copy(dAtA[i:], m.EnbUeS1ApId)
		i = encodeVarintC1Interface(dAtA, i, uint64(len(m.EnbUeS1ApId)))
		i--
		dAtA[i] = 0x2a
	}
	if len(m.MmeUeS1ApId) > 0 {
		i -= len(m.MmeUeS1ApId)
		copy(dAtA[i:], m.MmeUeS1ApId)
		i = encodeVarintC1Interface(dAtA, i, uint64(len(m.MmeUeS1ApId)))
		i--
		dAtA[i] = 0x22
	}
	if m.SCell != nil {
		{
			size, err := m.SCell.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintC1Interface(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x1a
	}
	if len(m.Crnti) > 0 {
		i -= len(m.Crnti)
		copy(dAtA[i:], m.Crnti)
		i = encodeVarintC1Interface(dAtA, i, uint64(len(m.Crnti)))
		i--
		dAtA[i] = 0x12
	}
	if len(m.Imsi) > 0 {
		i -= len(m.Imsi)
		copy(dAtA[i:], m.Imsi)
		i = encodeVarintC1Interface(dAtA, i, uint64(len(m.Imsi)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *C1RNIBLinkID) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *C1RNIBLinkID) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *C1RNIBLinkID) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.Imsi) > 0 {
		i -= len(m.Imsi)
		copy(dAtA[i:], m.Imsi)
		i = encodeVarintC1Interface(dAtA, i, uint64(len(m.Imsi)))
		i--
		dAtA[i] = 0x12
	}
	if m.Ecgi != nil {
		{
			size, err := m.Ecgi.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintC1Interface(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *C1RadioRepPerServCellAttribute) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *C1RadioRepPerServCellAttribute) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *C1RadioRepPerServCellAttribute) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.PucchSinrHist) > 0 {
		for iNdEx := len(m.PucchSinrHist) - 1; iNdEx >= 0; iNdEx-- {
			i -= len(m.PucchSinrHist[iNdEx])
			copy(dAtA[i:], m.PucchSinrHist[iNdEx])
			i = encodeVarintC1Interface(dAtA, i, uint64(len(m.PucchSinrHist[iNdEx])))
			i--
			dAtA[i] = 0x2a
		}
	}
	if len(m.PuschSinrHist) > 0 {
		for iNdEx := len(m.PuschSinrHist) - 1; iNdEx >= 0; iNdEx-- {
			i -= len(m.PuschSinrHist[iNdEx])
			copy(dAtA[i:], m.PuschSinrHist[iNdEx])
			i = encodeVarintC1Interface(dAtA, i, uint64(len(m.PuschSinrHist[iNdEx])))
			i--
			dAtA[i] = 0x22
		}
	}
	if len(m.RiHist) > 0 {
		for iNdEx := len(m.RiHist) - 1; iNdEx >= 0; iNdEx-- {
			i -= len(m.RiHist[iNdEx])
			copy(dAtA[i:], m.RiHist[iNdEx])
			i = encodeVarintC1Interface(dAtA, i, uint64(len(m.RiHist[iNdEx])))
			i--
			dAtA[i] = 0x1a
		}
	}
	if len(m.CqiHist) > 0 {
		for iNdEx := len(m.CqiHist) - 1; iNdEx >= 0; iNdEx-- {
			i -= len(m.CqiHist[iNdEx])
			copy(dAtA[i:], m.CqiHist[iNdEx])
			i = encodeVarintC1Interface(dAtA, i, uint64(len(m.CqiHist[iNdEx])))
			i--
			dAtA[i] = 0x12
		}
	}
	if m.Ecgi != nil {
		{
			size, err := m.Ecgi.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintC1Interface(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *C1RadioMeasReportPerUeAttribute) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *C1RadioMeasReportPerUeAttribute) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *C1RadioMeasReportPerUeAttribute) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.RadioRepPerServCell) > 0 {
		for iNdEx := len(m.RadioRepPerServCell) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.RadioRepPerServCell[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintC1Interface(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0xa
		}
	}
	return len(dAtA) - i, nil
}

func (m *C1RNIBLink) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *C1RNIBLink) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *C1RNIBLink) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.RadioMeasReportPerUe != nil {
		{
			size, err := m.RadioMeasReportPerUe.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintC1Interface(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x12
	}
	if m.LinkId != nil {
		{
			size, err := m.LinkId.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintC1Interface(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *C1HandoverRequest) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *C1HandoverRequest) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *C1HandoverRequest) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.DstCells != nil {
		{
			size, err := m.DstCells.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintC1Interface(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x1a
	}
	if m.SrcCells != nil {
		{
			size, err := m.SrcCells.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintC1Interface(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x12
	}
	if m.Links != nil {
		{
			size, err := m.Links.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintC1Interface(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *C1RRMConfiguration) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *C1RRMConfiguration) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *C1RRMConfiguration) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.TargetCells != nil {
		{
			size, err := m.TargetCells.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintC1Interface(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func encodeVarintC1Interface(dAtA []byte, offset int, v uint64) int {
	offset -= sovC1Interface(v)
	base := offset
	for v >= 1<<7 {
		dAtA[offset] = uint8(v&0x7f | 0x80)
		v >>= 7
		offset++
	}
	dAtA[offset] = uint8(v)
	return base
}
func (m *ECGI) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.Plmnid)
	if l > 0 {
		n += 1 + l + sovC1Interface(uint64(l))
	}
	l = len(m.Ecid)
	if l > 0 {
		n += 1 + l + sovC1Interface(uint64(l))
	}
	return n
}

func (m *StationListRequest) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Ecgi != nil {
		l = m.Ecgi.Size()
		n += 1 + l + sovC1Interface(uint64(l))
	}
	if m.Subscribe {
		n += 2
	}
	return n
}

func (m *StationInfo) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Ecgi != nil {
		l = m.Ecgi.Size()
		n += 1 + l + sovC1Interface(uint64(l))
	}
	if m.MaxNumConnectedUes != 0 {
		n += 1 + sovC1Interface(uint64(m.MaxNumConnectedUes))
	}
	return n
}

func (m *StationLinkListRequest) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Ecgi != nil {
		l = m.Ecgi.Size()
		n += 1 + l + sovC1Interface(uint64(l))
	}
	if m.Subscribe {
		n += 2
	}
	return n
}

func (m *StationLinkInfo) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Ecgi != nil {
		l = m.Ecgi.Size()
		n += 1 + l + sovC1Interface(uint64(l))
	}
	if len(m.NeighborECGI) > 0 {
		for _, e := range m.NeighborECGI {
			l = e.Size()
			n += 1 + l + sovC1Interface(uint64(l))
		}
	}
	return n
}

func (m *UELinkListRequest) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.Crnti)
	if l > 0 {
		n += 1 + l + sovC1Interface(uint64(l))
	}
	if m.Ecgi != nil {
		l = m.Ecgi.Size()
		n += 1 + l + sovC1Interface(uint64(l))
	}
	if m.Subscribe {
		n += 2
	}
	if m.NoReplay {
		n += 2
	}
	return n
}

func (m *ChannelQuality) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.TargetEcgi != nil {
		l = m.TargetEcgi.Size()
		n += 1 + l + sovC1Interface(uint64(l))
	}
	if m.CqiHist != 0 {
		n += 1 + sovC1Interface(uint64(m.CqiHist))
	}
	return n
}

func (m *UELinkInfo) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.Crnti)
	if l > 0 {
		n += 1 + l + sovC1Interface(uint64(l))
	}
	if m.Ecgi != nil {
		l = m.Ecgi.Size()
		n += 1 + l + sovC1Interface(uint64(l))
	}
	if len(m.ChannelQualities) > 0 {
		for _, e := range m.ChannelQualities {
			l = e.Size()
			n += 1 + l + sovC1Interface(uint64(l))
		}
	}
	l = len(m.Imsi)
	if l > 0 {
		n += 1 + l + sovC1Interface(uint64(l))
	}
	return n
}

func (m *HandOverRequest) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.Crnti)
	if l > 0 {
		n += 1 + l + sovC1Interface(uint64(l))
	}
	if m.SrcStation != nil {
		l = m.SrcStation.Size()
		n += 1 + l + sovC1Interface(uint64(l))
	}
	if m.DstStation != nil {
		l = m.DstStation.Size()
		n += 1 + l + sovC1Interface(uint64(l))
	}
	return n
}

func (m *HandOverResponse) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Success {
		n += 2
	}
	return n
}

func (m *RadioPowerRequest) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Ecgi != nil {
		l = m.Ecgi.Size()
		n += 1 + l + sovC1Interface(uint64(l))
	}
	if m.Offset != 0 {
		n += 1 + sovC1Interface(uint64(m.Offset))
	}
	return n
}

func (m *RadioPowerResponse) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Success {
		n += 2
	}
	return n
}

func (m *C1RequestMessage) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Header != nil {
		l = m.Header.Size()
		n += 1 + l + sovC1Interface(uint64(l))
	}
	if m.Payload != nil {
		l = m.Payload.Size()
		n += 1 + l + sovC1Interface(uint64(l))
	}
	return n
}

func (m *C1ResponseMessage) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Header != nil {
		l = m.Header.Size()
		n += 1 + l + sovC1Interface(uint64(l))
	}
	if m.Payload != nil {
		l = m.Payload.Size()
		n += 1 + l + sovC1Interface(uint64(l))
	}
	return n
}

func (m *C1RequestMessageHeader) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Type != 0 {
		n += 1 + sovC1Interface(uint64(m.Type))
	}
	return n
}

func (m *C1RequestMessagePayload) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Request != nil {
		n += m.Request.Size()
	}
	return n
}

func (m *C1RequestMessagePayload_RequestedRNIBType) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	n += 1 + sovC1Interface(uint64(m.RequestedRNIBType))
	return n
}
func (m *C1RequestMessagePayload_HandoverRequest) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.HandoverRequest != nil {
		l = m.HandoverRequest.Size()
		n += 1 + l + sovC1Interface(uint64(l))
	}
	return n
}
func (m *C1RequestMessagePayload_RrmConfigurationRequest) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.RrmConfigurationRequest != nil {
		l = m.RrmConfigurationRequest.Size()
		n += 1 + l + sovC1Interface(uint64(l))
	}
	return n
}
func (m *C1ResponseMessageHeader) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Type != 0 {
		n += 1 + sovC1Interface(uint64(m.Type))
	}
	return n
}

func (m *C1ResponseMessagePayload) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Result != nil {
		n += m.Result.Size()
	}
	return n
}

func (m *C1ResponseMessagePayload_ResponseCode) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.ResponseCode)
	n += 1 + l + sovC1Interface(uint64(l))
	return n
}
func (m *C1ResponseMessagePayload_RNIBCells) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.RNIBCells != nil {
		l = m.RNIBCells.Size()
		n += 1 + l + sovC1Interface(uint64(l))
	}
	return n
}
func (m *C1ResponseMessagePayload_RNIBUEs) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.RNIBUEs != nil {
		l = m.RNIBUEs.Size()
		n += 1 + l + sovC1Interface(uint64(l))
	}
	return n
}
func (m *C1ResponseMessagePayload_RNIBLinks) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.RNIBLinks != nil {
		l = m.RNIBLinks.Size()
		n += 1 + l + sovC1Interface(uint64(l))
	}
	return n
}
func (m *C1RNIBCells) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if len(m.RNIBCells) > 0 {
		for _, e := range m.RNIBCells {
			l = e.Size()
			n += 1 + l + sovC1Interface(uint64(l))
		}
	}
	return n
}

func (m *C1RNIBUEs) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if len(m.RNIBUEs) > 0 {
		for _, e := range m.RNIBUEs {
			l = e.Size()
			n += 1 + l + sovC1Interface(uint64(l))
		}
	}
	return n
}

func (m *C1RNIBLinks) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if len(m.RNIBLinks) > 0 {
		for _, e := range m.RNIBLinks {
			l = e.Size()
			n += 1 + l + sovC1Interface(uint64(l))
		}
	}
	return n
}

func (m *C1ECGI) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.PlmnId)
	if l > 0 {
		n += 1 + l + sovC1Interface(uint64(l))
	}
	l = len(m.Ecid)
	if l > 0 {
		n += 1 + l + sovC1Interface(uint64(l))
	}
	return n
}

func (m *C1CandScell) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.Pci)
	if l > 0 {
		n += 1 + l + sovC1Interface(uint64(l))
	}
	l = len(m.EarfcnDl)
	if l > 0 {
		n += 1 + l + sovC1Interface(uint64(l))
	}
	return n
}

func (m *C1RNIBCell) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Ecgi != nil {
		l = m.Ecgi.Size()
		n += 1 + l + sovC1Interface(uint64(l))
	}
	if m.CellConfiguration != nil {
		l = m.CellConfiguration.Size()
		n += 1 + l + sovC1Interface(uint64(l))
	}
	if m.RrmConfiguration != nil {
		l = m.RrmConfiguration.Size()
		n += 1 + l + sovC1Interface(uint64(l))
	}
	return n
}

func (m *C1CellConfigAttribute) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Ecgi != nil {
		l = m.Ecgi.Size()
		n += 1 + l + sovC1Interface(uint64(l))
	}
	l = len(m.Pci)
	if l > 0 {
		n += 1 + l + sovC1Interface(uint64(l))
	}
	if len(m.CandScells) > 0 {
		for _, e := range m.CandScells {
			l = e.Size()
			n += 1 + l + sovC1Interface(uint64(l))
		}
	}
	l = len(m.EarfcnDl)
	if l > 0 {
		n += 1 + l + sovC1Interface(uint64(l))
	}
	l = len(m.EarfcnUl)
	if l > 0 {
		n += 1 + l + sovC1Interface(uint64(l))
	}
	l = len(m.RbsPerTtiDl)
	if l > 0 {
		n += 1 + l + sovC1Interface(uint64(l))
	}
	l = len(m.RbsPerTtiUl)
	if l > 0 {
		n += 1 + l + sovC1Interface(uint64(l))
	}
	l = len(m.NumTxAntenna)
	if l > 0 {
		n += 1 + l + sovC1Interface(uint64(l))
	}
	l = len(m.DuplexMode)
	if l > 0 {
		n += 1 + l + sovC1Interface(uint64(l))
	}
	l = len(m.MaxNumConnectedUes)
	if l > 0 {
		n += 1 + l + sovC1Interface(uint64(l))
	}
	l = len(m.MaxNumConnectedBearers)
	if l > 0 {
		n += 1 + l + sovC1Interface(uint64(l))
	}
	l = len(m.MaxNumUesSchedPerTtiDl)
	if l > 0 {
		n += 1 + l + sovC1Interface(uint64(l))
	}
	l = len(m.MaxNumUesSchedPerTtiUl)
	if l > 0 {
		n += 1 + l + sovC1Interface(uint64(l))
	}
	l = len(m.DlfsSchedEnable)
	if l > 0 {
		n += 1 + l + sovC1Interface(uint64(l))
	}
	return n
}

func (m *C1PciArfcn) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.Pci)
	if l > 0 {
		n += 1 + l + sovC1Interface(uint64(l))
	}
	l = len(m.EarfcnDl)
	if l > 0 {
		n += 1 + l + sovC1Interface(uint64(l))
	}
	return n
}

func (m *C1RRMConfigAttribute) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Ecgi != nil {
		l = m.Ecgi.Size()
		n += 1 + l + sovC1Interface(uint64(l))
	}
	if len(m.Crnti) > 0 {
		for _, s := range m.Crnti {
			l = len(s)
			n += 1 + l + sovC1Interface(uint64(l))
		}
	}
	if m.PciArfcn != nil {
		l = m.PciArfcn.Size()
		n += 1 + l + sovC1Interface(uint64(l))
	}
	if len(m.Pa) > 0 {
		l = 0
		for _, e := range m.Pa {
			l += sovC1Interface(uint64(e))
		}
		n += 1 + sovC1Interface(uint64(l)) + l
	}
	if len(m.StartPrbDl) > 0 {
		for _, s := range m.StartPrbDl {
			l = len(s)
			n += 1 + l + sovC1Interface(uint64(l))
		}
	}
	if len(m.EndPrbDl) > 0 {
		for _, s := range m.EndPrbDl {
			l = len(s)
			n += 1 + l + sovC1Interface(uint64(l))
		}
	}
	if len(m.SubFrameBitmaskDl) > 0 {
		for _, s := range m.SubFrameBitmaskDl {
			l = len(s)
			n += 1 + l + sovC1Interface(uint64(l))
		}
	}
	if len(m.P0UePusch) > 0 {
		for _, s := range m.P0UePusch {
			l = len(s)
			n += 1 + l + sovC1Interface(uint64(l))
		}
	}
	if len(m.StartPrbUl) > 0 {
		for _, s := range m.StartPrbUl {
			l = len(s)
			n += 1 + l + sovC1Interface(uint64(l))
		}
	}
	if len(m.EndPrbUl) > 0 {
		for _, s := range m.EndPrbUl {
			l = len(s)
			n += 1 + l + sovC1Interface(uint64(l))
		}
	}
	if len(m.SubFrameBitmaskUl) > 0 {
		for _, s := range m.SubFrameBitmaskUl {
			l = len(s)
			n += 1 + l + sovC1Interface(uint64(l))
		}
	}
	return n
}

func (m *C1RNIBUE) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.Imsi)
	if l > 0 {
		n += 1 + l + sovC1Interface(uint64(l))
	}
	l = len(m.Crnti)
	if l > 0 {
		n += 1 + l + sovC1Interface(uint64(l))
	}
	if m.SCell != nil {
		l = m.SCell.Size()
		n += 1 + l + sovC1Interface(uint64(l))
	}
	l = len(m.MmeUeS1ApId)
	if l > 0 {
		n += 1 + l + sovC1Interface(uint64(l))
	}
	l = len(m.EnbUeS1ApId)
	if l > 0 {
		n += 1 + l + sovC1Interface(uint64(l))
	}
	return n
}

func (m *C1RNIBLinkID) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Ecgi != nil {
		l = m.Ecgi.Size()
		n += 1 + l + sovC1Interface(uint64(l))
	}
	l = len(m.Imsi)
	if l > 0 {
		n += 1 + l + sovC1Interface(uint64(l))
	}
	return n
}

func (m *C1RadioRepPerServCellAttribute) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Ecgi != nil {
		l = m.Ecgi.Size()
		n += 1 + l + sovC1Interface(uint64(l))
	}
	if len(m.CqiHist) > 0 {
		for _, s := range m.CqiHist {
			l = len(s)
			n += 1 + l + sovC1Interface(uint64(l))
		}
	}
	if len(m.RiHist) > 0 {
		for _, s := range m.RiHist {
			l = len(s)
			n += 1 + l + sovC1Interface(uint64(l))
		}
	}
	if len(m.PuschSinrHist) > 0 {
		for _, s := range m.PuschSinrHist {
			l = len(s)
			n += 1 + l + sovC1Interface(uint64(l))
		}
	}
	if len(m.PucchSinrHist) > 0 {
		for _, s := range m.PucchSinrHist {
			l = len(s)
			n += 1 + l + sovC1Interface(uint64(l))
		}
	}
	return n
}

func (m *C1RadioMeasReportPerUeAttribute) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if len(m.RadioRepPerServCell) > 0 {
		for _, e := range m.RadioRepPerServCell {
			l = e.Size()
			n += 1 + l + sovC1Interface(uint64(l))
		}
	}
	return n
}

func (m *C1RNIBLink) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.LinkId != nil {
		l = m.LinkId.Size()
		n += 1 + l + sovC1Interface(uint64(l))
	}
	if m.RadioMeasReportPerUe != nil {
		l = m.RadioMeasReportPerUe.Size()
		n += 1 + l + sovC1Interface(uint64(l))
	}
	return n
}

func (m *C1HandoverRequest) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Links != nil {
		l = m.Links.Size()
		n += 1 + l + sovC1Interface(uint64(l))
	}
	if m.SrcCells != nil {
		l = m.SrcCells.Size()
		n += 1 + l + sovC1Interface(uint64(l))
	}
	if m.DstCells != nil {
		l = m.DstCells.Size()
		n += 1 + l + sovC1Interface(uint64(l))
	}
	return n
}

func (m *C1RRMConfiguration) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.TargetCells != nil {
		l = m.TargetCells.Size()
		n += 1 + l + sovC1Interface(uint64(l))
	}
	return n
}

func sovC1Interface(x uint64) (n int) {
	return (math_bits.Len64(x|1) + 6) / 7
}
func sozC1Interface(x uint64) (n int) {
	return sovC1Interface(uint64((x << 1) ^ uint64((int64(x) >> 63))))
}
func (m *ECGI) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowC1Interface
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: ECGI: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: ECGI: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Plmnid", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowC1Interface
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthC1Interface
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthC1Interface
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Plmnid = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Ecid", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowC1Interface
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthC1Interface
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthC1Interface
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Ecid = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipC1Interface(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthC1Interface
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthC1Interface
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *StationListRequest) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowC1Interface
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: StationListRequest: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: StationListRequest: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Ecgi", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowC1Interface
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthC1Interface
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthC1Interface
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Ecgi == nil {
				m.Ecgi = &ECGI{}
			}
			if err := m.Ecgi.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Subscribe", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowC1Interface
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.Subscribe = bool(v != 0)
		default:
			iNdEx = preIndex
			skippy, err := skipC1Interface(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthC1Interface
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthC1Interface
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *StationInfo) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowC1Interface
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: StationInfo: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: StationInfo: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Ecgi", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowC1Interface
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthC1Interface
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthC1Interface
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Ecgi == nil {
				m.Ecgi = &ECGI{}
			}
			if err := m.Ecgi.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field MaxNumConnectedUes", wireType)
			}
			m.MaxNumConnectedUes = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowC1Interface
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.MaxNumConnectedUes |= uint32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipC1Interface(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthC1Interface
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthC1Interface
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *StationLinkListRequest) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowC1Interface
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: StationLinkListRequest: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: StationLinkListRequest: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Ecgi", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowC1Interface
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthC1Interface
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthC1Interface
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Ecgi == nil {
				m.Ecgi = &ECGI{}
			}
			if err := m.Ecgi.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Subscribe", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowC1Interface
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.Subscribe = bool(v != 0)
		default:
			iNdEx = preIndex
			skippy, err := skipC1Interface(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthC1Interface
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthC1Interface
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *StationLinkInfo) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowC1Interface
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: StationLinkInfo: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: StationLinkInfo: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Ecgi", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowC1Interface
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthC1Interface
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthC1Interface
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Ecgi == nil {
				m.Ecgi = &ECGI{}
			}
			if err := m.Ecgi.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field NeighborECGI", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowC1Interface
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthC1Interface
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthC1Interface
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.NeighborECGI = append(m.NeighborECGI, &ECGI{})
			if err := m.NeighborECGI[len(m.NeighborECGI)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipC1Interface(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthC1Interface
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthC1Interface
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *UELinkListRequest) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowC1Interface
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: UELinkListRequest: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: UELinkListRequest: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Crnti", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowC1Interface
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthC1Interface
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthC1Interface
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Crnti = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Ecgi", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowC1Interface
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthC1Interface
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthC1Interface
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Ecgi == nil {
				m.Ecgi = &ECGI{}
			}
			if err := m.Ecgi.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Subscribe", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowC1Interface
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.Subscribe = bool(v != 0)
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field NoReplay", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowC1Interface
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.NoReplay = bool(v != 0)
		default:
			iNdEx = preIndex
			skippy, err := skipC1Interface(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthC1Interface
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthC1Interface
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *ChannelQuality) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowC1Interface
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: ChannelQuality: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: ChannelQuality: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field TargetEcgi", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowC1Interface
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthC1Interface
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthC1Interface
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.TargetEcgi == nil {
				m.TargetEcgi = &ECGI{}
			}
			if err := m.TargetEcgi.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field CqiHist", wireType)
			}
			m.CqiHist = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowC1Interface
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.CqiHist |= uint32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipC1Interface(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthC1Interface
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthC1Interface
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *UELinkInfo) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowC1Interface
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: UELinkInfo: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: UELinkInfo: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Crnti", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowC1Interface
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthC1Interface
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthC1Interface
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Crnti = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Ecgi", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowC1Interface
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthC1Interface
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthC1Interface
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Ecgi == nil {
				m.Ecgi = &ECGI{}
			}
			if err := m.Ecgi.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ChannelQualities", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowC1Interface
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthC1Interface
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthC1Interface
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ChannelQualities = append(m.ChannelQualities, &ChannelQuality{})
			if err := m.ChannelQualities[len(m.ChannelQualities)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Imsi", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowC1Interface
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthC1Interface
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthC1Interface
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Imsi = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipC1Interface(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthC1Interface
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthC1Interface
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *HandOverRequest) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowC1Interface
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: HandOverRequest: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: HandOverRequest: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Crnti", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowC1Interface
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthC1Interface
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthC1Interface
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Crnti = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field SrcStation", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowC1Interface
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthC1Interface
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthC1Interface
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.SrcStation == nil {
				m.SrcStation = &ECGI{}
			}
			if err := m.SrcStation.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field DstStation", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowC1Interface
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthC1Interface
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthC1Interface
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.DstStation == nil {
				m.DstStation = &ECGI{}
			}
			if err := m.DstStation.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipC1Interface(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthC1Interface
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthC1Interface
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *HandOverResponse) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowC1Interface
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: HandOverResponse: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: HandOverResponse: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Success", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowC1Interface
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.Success = bool(v != 0)
		default:
			iNdEx = preIndex
			skippy, err := skipC1Interface(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthC1Interface
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthC1Interface
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *RadioPowerRequest) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowC1Interface
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: RadioPowerRequest: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: RadioPowerRequest: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Ecgi", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowC1Interface
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthC1Interface
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthC1Interface
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Ecgi == nil {
				m.Ecgi = &ECGI{}
			}
			if err := m.Ecgi.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Offset", wireType)
			}
			m.Offset = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowC1Interface
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Offset |= StationPowerOffset(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipC1Interface(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthC1Interface
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthC1Interface
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *RadioPowerResponse) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowC1Interface
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: RadioPowerResponse: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: RadioPowerResponse: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Success", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowC1Interface
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.Success = bool(v != 0)
		default:
			iNdEx = preIndex
			skippy, err := skipC1Interface(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthC1Interface
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthC1Interface
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *C1RequestMessage) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowC1Interface
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: C1RequestMessage: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: C1RequestMessage: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Header", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowC1Interface
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthC1Interface
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthC1Interface
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Header == nil {
				m.Header = &C1RequestMessageHeader{}
			}
			if err := m.Header.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Payload", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowC1Interface
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthC1Interface
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthC1Interface
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Payload == nil {
				m.Payload = &C1RequestMessagePayload{}
			}
			if err := m.Payload.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipC1Interface(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthC1Interface
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthC1Interface
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *C1ResponseMessage) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowC1Interface
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: C1ResponseMessage: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: C1ResponseMessage: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Header", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowC1Interface
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthC1Interface
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthC1Interface
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Header == nil {
				m.Header = &C1ResponseMessageHeader{}
			}
			if err := m.Header.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Payload", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowC1Interface
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthC1Interface
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthC1Interface
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Payload == nil {
				m.Payload = &C1ResponseMessagePayload{}
			}
			if err := m.Payload.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipC1Interface(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthC1Interface
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthC1Interface
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *C1RequestMessageHeader) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowC1Interface
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: C1RequestMessageHeader: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: C1RequestMessageHeader: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Type", wireType)
			}
			m.Type = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowC1Interface
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Type |= C1MessageType(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipC1Interface(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthC1Interface
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthC1Interface
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *C1RequestMessagePayload) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowC1Interface
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: C1RequestMessagePayload: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: C1RequestMessagePayload: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field RequestedRNIBType", wireType)
			}
			var v C1RNIBType
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowC1Interface
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= C1RNIBType(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.Request = &C1RequestMessagePayload_RequestedRNIBType{v}
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field HandoverRequest", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowC1Interface
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthC1Interface
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthC1Interface
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &C1HandoverRequest{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.Request = &C1RequestMessagePayload_HandoverRequest{v}
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field RrmConfigurationRequest", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowC1Interface
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthC1Interface
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthC1Interface
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &C1RRMConfiguration{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.Request = &C1RequestMessagePayload_RrmConfigurationRequest{v}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipC1Interface(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthC1Interface
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthC1Interface
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *C1ResponseMessageHeader) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowC1Interface
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: C1ResponseMessageHeader: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: C1ResponseMessageHeader: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Type", wireType)
			}
			m.Type = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowC1Interface
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Type |= C1MessageType(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipC1Interface(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthC1Interface
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthC1Interface
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *C1ResponseMessagePayload) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowC1Interface
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: C1ResponseMessagePayload: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: C1ResponseMessagePayload: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ResponseCode", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowC1Interface
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthC1Interface
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthC1Interface
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Result = &C1ResponseMessagePayload_ResponseCode{string(dAtA[iNdEx:postIndex])}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field RNIBCells", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowC1Interface
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthC1Interface
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthC1Interface
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &C1RNIBCells{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.Result = &C1ResponseMessagePayload_RNIBCells{v}
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field RNIBUEs", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowC1Interface
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthC1Interface
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthC1Interface
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &C1RNIBUEs{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.Result = &C1ResponseMessagePayload_RNIBUEs{v}
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field RNIBLinks", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowC1Interface
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthC1Interface
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthC1Interface
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &C1RNIBLinks{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.Result = &C1ResponseMessagePayload_RNIBLinks{v}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipC1Interface(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthC1Interface
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthC1Interface
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *C1RNIBCells) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowC1Interface
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: C1RNIBCells: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: C1RNIBCells: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field RNIBCells", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowC1Interface
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthC1Interface
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthC1Interface
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.RNIBCells = append(m.RNIBCells, &C1RNIBCell{})
			if err := m.RNIBCells[len(m.RNIBCells)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipC1Interface(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthC1Interface
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthC1Interface
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *C1RNIBUEs) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowC1Interface
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: C1RNIBUEs: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: C1RNIBUEs: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field RNIBUEs", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowC1Interface
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthC1Interface
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthC1Interface
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.RNIBUEs = append(m.RNIBUEs, &C1RNIBUE{})
			if err := m.RNIBUEs[len(m.RNIBUEs)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipC1Interface(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthC1Interface
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthC1Interface
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *C1RNIBLinks) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowC1Interface
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: C1RNIBLinks: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: C1RNIBLinks: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field RNIBLinks", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowC1Interface
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthC1Interface
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthC1Interface
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.RNIBLinks = append(m.RNIBLinks, &C1RNIBLink{})
			if err := m.RNIBLinks[len(m.RNIBLinks)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipC1Interface(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthC1Interface
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthC1Interface
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *C1ECGI) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowC1Interface
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: C1ECGI: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: C1ECGI: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field PlmnId", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowC1Interface
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthC1Interface
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthC1Interface
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.PlmnId = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Ecid", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowC1Interface
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthC1Interface
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthC1Interface
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Ecid = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipC1Interface(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthC1Interface
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthC1Interface
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *C1CandScell) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowC1Interface
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: C1CandScell: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: C1CandScell: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Pci", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowC1Interface
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthC1Interface
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthC1Interface
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Pci = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field EarfcnDl", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowC1Interface
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthC1Interface
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthC1Interface
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.EarfcnDl = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipC1Interface(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthC1Interface
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthC1Interface
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *C1RNIBCell) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowC1Interface
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: C1RNIBCell: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: C1RNIBCell: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Ecgi", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowC1Interface
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthC1Interface
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthC1Interface
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Ecgi == nil {
				m.Ecgi = &C1ECGI{}
			}
			if err := m.Ecgi.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field CellConfiguration", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowC1Interface
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthC1Interface
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthC1Interface
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.CellConfiguration == nil {
				m.CellConfiguration = &C1CellConfigAttribute{}
			}
			if err := m.CellConfiguration.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field RrmConfiguration", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowC1Interface
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthC1Interface
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthC1Interface
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.RrmConfiguration == nil {
				m.RrmConfiguration = &C1RRMConfigAttribute{}
			}
			if err := m.RrmConfiguration.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipC1Interface(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthC1Interface
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthC1Interface
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *C1CellConfigAttribute) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowC1Interface
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: C1CellConfigAttribute: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: C1CellConfigAttribute: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Ecgi", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowC1Interface
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthC1Interface
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthC1Interface
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Ecgi == nil {
				m.Ecgi = &C1ECGI{}
			}
			if err := m.Ecgi.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Pci", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowC1Interface
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthC1Interface
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthC1Interface
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Pci = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field CandScells", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowC1Interface
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthC1Interface
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthC1Interface
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.CandScells = append(m.CandScells, &C1CandScell{})
			if err := m.CandScells[len(m.CandScells)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field EarfcnDl", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowC1Interface
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthC1Interface
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthC1Interface
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.EarfcnDl = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field EarfcnUl", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowC1Interface
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthC1Interface
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthC1Interface
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.EarfcnUl = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 6:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field RbsPerTtiDl", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowC1Interface
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthC1Interface
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthC1Interface
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.RbsPerTtiDl = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 7:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field RbsPerTtiUl", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowC1Interface
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthC1Interface
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthC1Interface
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.RbsPerTtiUl = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 8:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field NumTxAntenna", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowC1Interface
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthC1Interface
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthC1Interface
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.NumTxAntenna = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 9:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field DuplexMode", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowC1Interface
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthC1Interface
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthC1Interface
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.DuplexMode = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 10:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field MaxNumConnectedUes", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowC1Interface
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthC1Interface
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthC1Interface
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.MaxNumConnectedUes = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 11:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field MaxNumConnectedBearers", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowC1Interface
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthC1Interface
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthC1Interface
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.MaxNumConnectedBearers = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 12:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field MaxNumUesSchedPerTtiDl", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowC1Interface
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthC1Interface
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthC1Interface
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.MaxNumUesSchedPerTtiDl = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 13:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field MaxNumUesSchedPerTtiUl", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowC1Interface
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthC1Interface
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthC1Interface
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.MaxNumUesSchedPerTtiUl = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 14:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field DlfsSchedEnable", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowC1Interface
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthC1Interface
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthC1Interface
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.DlfsSchedEnable = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipC1Interface(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthC1Interface
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthC1Interface
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *C1PciArfcn) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowC1Interface
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: C1PciArfcn: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: C1PciArfcn: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Pci", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowC1Interface
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthC1Interface
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthC1Interface
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Pci = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field EarfcnDl", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowC1Interface
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthC1Interface
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthC1Interface
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.EarfcnDl = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipC1Interface(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthC1Interface
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthC1Interface
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *C1RRMConfigAttribute) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowC1Interface
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: C1RRMConfigAttribute: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: C1RRMConfigAttribute: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Ecgi", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowC1Interface
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthC1Interface
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthC1Interface
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Ecgi == nil {
				m.Ecgi = &C1ECGI{}
			}
			if err := m.Ecgi.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Crnti", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowC1Interface
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthC1Interface
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthC1Interface
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Crnti = append(m.Crnti, string(dAtA[iNdEx:postIndex]))
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field PciArfcn", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowC1Interface
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthC1Interface
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthC1Interface
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.PciArfcn == nil {
				m.PciArfcn = &C1PciArfcn{}
			}
			if err := m.PciArfcn.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 4:
			if wireType == 0 {
				var v C1XICICPA
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowC1Interface
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					v |= C1XICICPA(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				m.Pa = append(m.Pa, v)
			} else if wireType == 2 {
				var packedLen int
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowC1Interface
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					packedLen |= int(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				if packedLen < 0 {
					return ErrInvalidLengthC1Interface
				}
				postIndex := iNdEx + packedLen
				if postIndex < 0 {
					return ErrInvalidLengthC1Interface
				}
				if postIndex > l {
					return io.ErrUnexpectedEOF
				}
				var elementCount int
				if elementCount != 0 && len(m.Pa) == 0 {
					m.Pa = make([]C1XICICPA, 0, elementCount)
				}
				for iNdEx < postIndex {
					var v C1XICICPA
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowC1Interface
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						v |= C1XICICPA(b&0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					m.Pa = append(m.Pa, v)
				}
			} else {
				return fmt.Errorf("proto: wrong wireType = %d for field Pa", wireType)
			}
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field StartPrbDl", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowC1Interface
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthC1Interface
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthC1Interface
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.StartPrbDl = append(m.StartPrbDl, string(dAtA[iNdEx:postIndex]))
			iNdEx = postIndex
		case 6:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field EndPrbDl", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowC1Interface
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthC1Interface
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthC1Interface
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.EndPrbDl = append(m.EndPrbDl, string(dAtA[iNdEx:postIndex]))
			iNdEx = postIndex
		case 7:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field SubFrameBitmaskDl", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowC1Interface
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthC1Interface
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthC1Interface
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.SubFrameBitmaskDl = append(m.SubFrameBitmaskDl, string(dAtA[iNdEx:postIndex]))
			iNdEx = postIndex
		case 8:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field P0UePusch", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowC1Interface
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthC1Interface
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthC1Interface
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.P0UePusch = append(m.P0UePusch, string(dAtA[iNdEx:postIndex]))
			iNdEx = postIndex
		case 9:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field StartPrbUl", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowC1Interface
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthC1Interface
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthC1Interface
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.StartPrbUl = append(m.StartPrbUl, string(dAtA[iNdEx:postIndex]))
			iNdEx = postIndex
		case 10:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field EndPrbUl", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowC1Interface
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthC1Interface
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthC1Interface
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.EndPrbUl = append(m.EndPrbUl, string(dAtA[iNdEx:postIndex]))
			iNdEx = postIndex
		case 11:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field SubFrameBitmaskUl", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowC1Interface
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthC1Interface
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthC1Interface
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.SubFrameBitmaskUl = append(m.SubFrameBitmaskUl, string(dAtA[iNdEx:postIndex]))
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipC1Interface(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthC1Interface
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthC1Interface
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *C1RNIBUE) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowC1Interface
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: C1RNIBUE: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: C1RNIBUE: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Imsi", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowC1Interface
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthC1Interface
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthC1Interface
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Imsi = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Crnti", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowC1Interface
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthC1Interface
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthC1Interface
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Crnti = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field SCell", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowC1Interface
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthC1Interface
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthC1Interface
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.SCell == nil {
				m.SCell = &C1ECGI{}
			}
			if err := m.SCell.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field MmeUeS1ApId", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowC1Interface
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthC1Interface
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthC1Interface
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.MmeUeS1ApId = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field EnbUeS1ApId", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowC1Interface
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthC1Interface
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthC1Interface
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.EnbUeS1ApId = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipC1Interface(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthC1Interface
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthC1Interface
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *C1RNIBLinkID) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowC1Interface
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: C1RNIBLinkID: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: C1RNIBLinkID: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Ecgi", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowC1Interface
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthC1Interface
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthC1Interface
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Ecgi == nil {
				m.Ecgi = &C1ECGI{}
			}
			if err := m.Ecgi.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Imsi", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowC1Interface
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthC1Interface
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthC1Interface
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Imsi = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipC1Interface(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthC1Interface
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthC1Interface
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *C1RadioRepPerServCellAttribute) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowC1Interface
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: C1RadioRepPerServCellAttribute: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: C1RadioRepPerServCellAttribute: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Ecgi", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowC1Interface
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthC1Interface
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthC1Interface
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Ecgi == nil {
				m.Ecgi = &C1ECGI{}
			}
			if err := m.Ecgi.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field CqiHist", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowC1Interface
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthC1Interface
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthC1Interface
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.CqiHist = append(m.CqiHist, string(dAtA[iNdEx:postIndex]))
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field RiHist", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowC1Interface
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthC1Interface
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthC1Interface
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.RiHist = append(m.RiHist, string(dAtA[iNdEx:postIndex]))
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field PuschSinrHist", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowC1Interface
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthC1Interface
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthC1Interface
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.PuschSinrHist = append(m.PuschSinrHist, string(dAtA[iNdEx:postIndex]))
			iNdEx = postIndex
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field PucchSinrHist", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowC1Interface
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthC1Interface
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthC1Interface
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.PucchSinrHist = append(m.PucchSinrHist, string(dAtA[iNdEx:postIndex]))
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipC1Interface(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthC1Interface
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthC1Interface
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *C1RadioMeasReportPerUeAttribute) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowC1Interface
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: C1RadioMeasReportPerUeAttribute: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: C1RadioMeasReportPerUeAttribute: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field RadioRepPerServCell", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowC1Interface
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthC1Interface
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthC1Interface
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.RadioRepPerServCell = append(m.RadioRepPerServCell, &C1RadioRepPerServCellAttribute{})
			if err := m.RadioRepPerServCell[len(m.RadioRepPerServCell)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipC1Interface(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthC1Interface
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthC1Interface
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *C1RNIBLink) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowC1Interface
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: C1RNIBLink: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: C1RNIBLink: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field LinkId", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowC1Interface
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthC1Interface
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthC1Interface
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.LinkId == nil {
				m.LinkId = &C1RNIBLinkID{}
			}
			if err := m.LinkId.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field RadioMeasReportPerUe", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowC1Interface
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthC1Interface
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthC1Interface
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.RadioMeasReportPerUe == nil {
				m.RadioMeasReportPerUe = &C1RadioMeasReportPerUeAttribute{}
			}
			if err := m.RadioMeasReportPerUe.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipC1Interface(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthC1Interface
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthC1Interface
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *C1HandoverRequest) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowC1Interface
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: C1HandoverRequest: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: C1HandoverRequest: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Links", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowC1Interface
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthC1Interface
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthC1Interface
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Links == nil {
				m.Links = &C1RNIBLinks{}
			}
			if err := m.Links.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field SrcCells", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowC1Interface
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthC1Interface
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthC1Interface
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.SrcCells == nil {
				m.SrcCells = &C1RNIBCells{}
			}
			if err := m.SrcCells.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field DstCells", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowC1Interface
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthC1Interface
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthC1Interface
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.DstCells == nil {
				m.DstCells = &C1RNIBCells{}
			}
			if err := m.DstCells.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipC1Interface(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthC1Interface
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthC1Interface
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *C1RRMConfiguration) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowC1Interface
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: C1RRMConfiguration: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: C1RRMConfiguration: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field TargetCells", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowC1Interface
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthC1Interface
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthC1Interface
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.TargetCells == nil {
				m.TargetCells = &C1RNIBCells{}
			}
			if err := m.TargetCells.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipC1Interface(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthC1Interface
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthC1Interface
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func skipC1Interface(dAtA []byte) (n int, err error) {
	l := len(dAtA)
	iNdEx := 0
	depth := 0
	for iNdEx < l {
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return 0, ErrIntOverflowC1Interface
			}
			if iNdEx >= l {
				return 0, io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		wireType := int(wire & 0x7)
		switch wireType {
		case 0:
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return 0, ErrIntOverflowC1Interface
				}
				if iNdEx >= l {
					return 0, io.ErrUnexpectedEOF
				}
				iNdEx++
				if dAtA[iNdEx-1] < 0x80 {
					break
				}
			}
		case 1:
			iNdEx += 8
		case 2:
			var length int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return 0, ErrIntOverflowC1Interface
				}
				if iNdEx >= l {
					return 0, io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				length |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if length < 0 {
				return 0, ErrInvalidLengthC1Interface
			}
			iNdEx += length
		case 3:
			depth++
		case 4:
			if depth == 0 {
				return 0, ErrUnexpectedEndOfGroupC1Interface
			}
			depth--
		case 5:
			iNdEx += 4
		default:
			return 0, fmt.Errorf("proto: illegal wireType %d", wireType)
		}
		if iNdEx < 0 {
			return 0, ErrInvalidLengthC1Interface
		}
		if depth == 0 {
			return iNdEx, nil
		}
	}
	return 0, io.ErrUnexpectedEOF
}

var (
	ErrInvalidLengthC1Interface        = fmt.Errorf("proto: negative length found during unmarshaling")
	ErrIntOverflowC1Interface          = fmt.Errorf("proto: integer overflow")
	ErrUnexpectedEndOfGroupC1Interface = fmt.Errorf("proto: unexpected end of group")
)
