// Code generated by protoc-gen-gogo. DO NOT EDIT.
// source: api/sb/e2sm/e2sm.proto

package e2sm

import (
	fmt "fmt"
	proto "github.com/gogo/protobuf/proto"
	sb "github.com/onosproject/onos-ric/api/sb"
	io "io"
	math "math"
	math_bits "math/bits"
)

// Reference imports to suppress errors if they are not otherwise used.
var _ = proto.Marshal
var _ = fmt.Errorf
var _ = math.Inf

// This is a compile-time assertion to ensure that this generated file
// is compatible with the proto package it is being compiled against.
// A compilation error at this line likely means your copy of the
// proto package needs to be updated.
const _ = proto.GoGoProtoPackageIsVersion3 // please upgrade the proto package

//
//-- **************************************************************
//-- Following IE defined in E2SM
//-- **************************************************************
//RICcontrolHeader ::= OCTET STRING
type RicControlHeader struct {
	MessageType sb.MessageType `protobuf:"varint,1,opt,name=messageType,proto3,enum=interface.e2.MessageType" json:"messageType,omitempty"`
}

func (m *RicControlHeader) Reset()         { *m = RicControlHeader{} }
func (m *RicControlHeader) String() string { return proto.CompactTextString(m) }
func (*RicControlHeader) ProtoMessage()    {}
func (*RicControlHeader) Descriptor() ([]byte, []int) {
	return fileDescriptor_048d76895a87e9ca, []int{0}
}
func (m *RicControlHeader) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *RicControlHeader) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_RicControlHeader.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *RicControlHeader) XXX_Merge(src proto.Message) {
	xxx_messageInfo_RicControlHeader.Merge(m, src)
}
func (m *RicControlHeader) XXX_Size() int {
	return m.Size()
}
func (m *RicControlHeader) XXX_DiscardUnknown() {
	xxx_messageInfo_RicControlHeader.DiscardUnknown(m)
}

var xxx_messageInfo_RicControlHeader proto.InternalMessageInfo

func (m *RicControlHeader) GetMessageType() sb.MessageType {
	if m != nil {
		return m.MessageType
	}
	return sb.MessageType_UNKNOWN_MESSAGE
}

type RicControlMessage struct {
	// Types that are valid to be assigned to S:
	//	*RicControlMessage_RRMConfig
	//	*RicControlMessage_HORequest
	S isRicControlMessage_S `protobuf_oneof:"s"`
}

func (m *RicControlMessage) Reset()         { *m = RicControlMessage{} }
func (m *RicControlMessage) String() string { return proto.CompactTextString(m) }
func (*RicControlMessage) ProtoMessage()    {}
func (*RicControlMessage) Descriptor() ([]byte, []int) {
	return fileDescriptor_048d76895a87e9ca, []int{1}
}
func (m *RicControlMessage) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *RicControlMessage) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_RicControlMessage.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *RicControlMessage) XXX_Merge(src proto.Message) {
	xxx_messageInfo_RicControlMessage.Merge(m, src)
}
func (m *RicControlMessage) XXX_Size() int {
	return m.Size()
}
func (m *RicControlMessage) XXX_DiscardUnknown() {
	xxx_messageInfo_RicControlMessage.DiscardUnknown(m)
}

var xxx_messageInfo_RicControlMessage proto.InternalMessageInfo

type isRicControlMessage_S interface {
	isRicControlMessage_S()
	MarshalTo([]byte) (int, error)
	Size() int
}

type RicControlMessage_RRMConfig struct {
	RRMConfig *sb.RRMConfig `protobuf:"bytes,1,opt,name=rRMConfig,proto3,oneof" json:"rRMConfig,omitempty"`
}
type RicControlMessage_HORequest struct {
	HORequest *sb.HORequest `protobuf:"bytes,2,opt,name=hORequest,proto3,oneof" json:"hORequest,omitempty"`
}

func (*RicControlMessage_RRMConfig) isRicControlMessage_S() {}
func (*RicControlMessage_HORequest) isRicControlMessage_S() {}

func (m *RicControlMessage) GetS() isRicControlMessage_S {
	if m != nil {
		return m.S
	}
	return nil
}

func (m *RicControlMessage) GetRRMConfig() *sb.RRMConfig {
	if x, ok := m.GetS().(*RicControlMessage_RRMConfig); ok {
		return x.RRMConfig
	}
	return nil
}

func (m *RicControlMessage) GetHORequest() *sb.HORequest {
	if x, ok := m.GetS().(*RicControlMessage_HORequest); ok {
		return x.HORequest
	}
	return nil
}

// XXX_OneofWrappers is for the internal use of the proto package.
func (*RicControlMessage) XXX_OneofWrappers() []interface{} {
	return []interface{}{
		(*RicControlMessage_RRMConfig)(nil),
		(*RicControlMessage_HORequest)(nil),
	}
}

type RicControlOutcome struct {
	// Types that are valid to be assigned to S:
	//	*RicControlOutcome_HOComplete
	//	*RicControlOutcome_HOFailure
	S isRicControlOutcome_S `protobuf_oneof:"s"`
}

func (m *RicControlOutcome) Reset()         { *m = RicControlOutcome{} }
func (m *RicControlOutcome) String() string { return proto.CompactTextString(m) }
func (*RicControlOutcome) ProtoMessage()    {}
func (*RicControlOutcome) Descriptor() ([]byte, []int) {
	return fileDescriptor_048d76895a87e9ca, []int{2}
}
func (m *RicControlOutcome) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *RicControlOutcome) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_RicControlOutcome.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *RicControlOutcome) XXX_Merge(src proto.Message) {
	xxx_messageInfo_RicControlOutcome.Merge(m, src)
}
func (m *RicControlOutcome) XXX_Size() int {
	return m.Size()
}
func (m *RicControlOutcome) XXX_DiscardUnknown() {
	xxx_messageInfo_RicControlOutcome.DiscardUnknown(m)
}

var xxx_messageInfo_RicControlOutcome proto.InternalMessageInfo

type isRicControlOutcome_S interface {
	isRicControlOutcome_S()
	MarshalTo([]byte) (int, error)
	Size() int
}

type RicControlOutcome_HOComplete struct {
	HOComplete *sb.HOComplete `protobuf:"bytes,1,opt,name=hOComplete,proto3,oneof" json:"hOComplete,omitempty"`
}
type RicControlOutcome_HOFailure struct {
	HOFailure *sb.HOFailure `protobuf:"bytes,2,opt,name=hOFailure,proto3,oneof" json:"hOFailure,omitempty"`
}

func (*RicControlOutcome_HOComplete) isRicControlOutcome_S() {}
func (*RicControlOutcome_HOFailure) isRicControlOutcome_S()  {}

func (m *RicControlOutcome) GetS() isRicControlOutcome_S {
	if m != nil {
		return m.S
	}
	return nil
}

func (m *RicControlOutcome) GetHOComplete() *sb.HOComplete {
	if x, ok := m.GetS().(*RicControlOutcome_HOComplete); ok {
		return x.HOComplete
	}
	return nil
}

func (m *RicControlOutcome) GetHOFailure() *sb.HOFailure {
	if x, ok := m.GetS().(*RicControlOutcome_HOFailure); ok {
		return x.HOFailure
	}
	return nil
}

// XXX_OneofWrappers is for the internal use of the proto package.
func (*RicControlOutcome) XXX_OneofWrappers() []interface{} {
	return []interface{}{
		(*RicControlOutcome_HOComplete)(nil),
		(*RicControlOutcome_HOFailure)(nil),
	}
}

func init() {
	proto.RegisterType((*RicControlHeader)(nil), "interface.e2sm.RicControlHeader")
	proto.RegisterType((*RicControlMessage)(nil), "interface.e2sm.RicControlMessage")
	proto.RegisterType((*RicControlOutcome)(nil), "interface.e2sm.RicControlOutcome")
}

func init() { proto.RegisterFile("api/sb/e2sm/e2sm.proto", fileDescriptor_048d76895a87e9ca) }

var fileDescriptor_048d76895a87e9ca = []byte{
	// 302 bytes of a gzipped FileDescriptorProto
	0x1f, 0x8b, 0x08, 0x00, 0x00, 0x00, 0x00, 0x00, 0x02, 0xff, 0x74, 0x91, 0x41, 0x4b, 0xb4, 0x40,
	0x1c, 0xc6, 0x9d, 0xf7, 0x85, 0xa0, 0x59, 0x58, 0xca, 0x43, 0x59, 0x87, 0x21, 0xf6, 0xd4, 0x65,
	0x15, 0xb6, 0x43, 0x54, 0xb7, 0x15, 0xc2, 0xcb, 0x22, 0x0c, 0x7d, 0x01, 0x9d, 0xfe, 0xab, 0x13,
	0xea, 0xd8, 0xcc, 0x78, 0xe8, 0x2b, 0x04, 0x41, 0x1f, 0xab, 0xe3, 0x1e, 0x3b, 0x86, 0x7e, 0x91,
	0x70, 0x56, 0x57, 0x37, 0xea, 0x22, 0xea, 0xf3, 0x3c, 0xbf, 0xf9, 0xc1, 0xe0, 0x93, 0xa8, 0xe4,
	0x9e, 0x8a, 0x3d, 0x58, 0xa8, 0xdc, 0x3c, 0xdc, 0x52, 0x0a, 0x2d, 0xec, 0x29, 0x2f, 0x34, 0xc8,
	0x75, 0xc4, 0xc0, 0x6d, 0xff, 0x9e, 0xdf, 0x24, 0x5c, 0xa7, 0x55, 0xec, 0x32, 0x91, 0x7b, 0xa2,
	0x10, 0xaa, 0x94, 0xe2, 0x09, 0x98, 0x36, 0xef, 0x73, 0xc9, 0x99, 0xb7, 0xe3, 0xcc, 0x87, 0xa5,
	0x41, 0xcd, 0x42, 0x7c, 0x44, 0x39, 0xf3, 0x45, 0xa1, 0xa5, 0xc8, 0x02, 0x88, 0x1e, 0x41, 0xda,
	0x77, 0x78, 0x92, 0x83, 0x52, 0x51, 0x02, 0x0f, 0x2f, 0x25, 0x38, 0xe8, 0x02, 0x5d, 0x4e, 0x17,
	0x67, 0xee, 0xf8, 0x50, 0x77, 0x35, 0x14, 0xe8, 0xb8, 0x3d, 0x7b, 0x45, 0xf8, 0x78, 0x20, 0x76,
	0x35, 0xfb, 0x1a, 0x1f, 0x4a, 0xba, 0xf2, 0x45, 0xb1, 0xe6, 0x89, 0x01, 0x4e, 0x16, 0xa7, 0xfb,
	0x40, 0xda, 0xc7, 0x81, 0x45, 0x87, 0x6e, 0x3b, 0x4c, 0x43, 0x0a, 0xcf, 0x15, 0x28, 0xed, 0xfc,
	0xfb, 0x6d, 0x18, 0xf4, 0x71, 0x3b, 0xdc, 0x75, 0x97, 0xff, 0x31, 0x52, 0xb3, 0xb7, 0x3d, 0x99,
	0xb0, 0xd2, 0x4c, 0xe4, 0x60, 0xdf, 0x62, 0x9c, 0x86, 0xbe, 0xc8, 0xcb, 0x0c, 0x34, 0x74, 0x36,
	0xce, 0x4f, 0x68, 0x9f, 0x07, 0x16, 0x1d, 0xb5, 0xb7, 0x3e, 0xf7, 0x11, 0xcf, 0x2a, 0x09, 0x7f,
	0xf9, 0x74, 0xf1, 0xd6, 0xa7, 0xfb, 0x30, 0x3e, 0x4b, 0xe7, 0xa3, 0x26, 0x68, 0x53, 0x13, 0xf4,
	0x55, 0x13, 0xf4, 0xde, 0x10, 0x6b, 0xd3, 0x10, 0xeb, 0xb3, 0x21, 0x56, 0x7c, 0x60, 0xae, 0xe3,
	0xea, 0x3b, 0x00, 0x00, 0xff, 0xff, 0x72, 0x55, 0xe0, 0x02, 0xf3, 0x01, 0x00, 0x00,
}

func (m *RicControlHeader) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *RicControlHeader) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *RicControlHeader) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.MessageType != 0 {
		i = encodeVarintE2Sm(dAtA, i, uint64(m.MessageType))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *RicControlMessage) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *RicControlMessage) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *RicControlMessage) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.S != nil {
		{
			size := m.S.Size()
			i -= size
			if _, err := m.S.MarshalTo(dAtA[i:]); err != nil {
				return 0, err
			}
		}
	}
	return len(dAtA) - i, nil
}

func (m *RicControlMessage_RRMConfig) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *RicControlMessage_RRMConfig) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	if m.RRMConfig != nil {
		{
			size, err := m.RRMConfig.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintE2Sm(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}
func (m *RicControlMessage_HORequest) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *RicControlMessage_HORequest) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	if m.HORequest != nil {
		{
			size, err := m.HORequest.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintE2Sm(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x12
	}
	return len(dAtA) - i, nil
}
func (m *RicControlOutcome) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *RicControlOutcome) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *RicControlOutcome) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.S != nil {
		{
			size := m.S.Size()
			i -= size
			if _, err := m.S.MarshalTo(dAtA[i:]); err != nil {
				return 0, err
			}
		}
	}
	return len(dAtA) - i, nil
}

func (m *RicControlOutcome_HOComplete) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *RicControlOutcome_HOComplete) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	if m.HOComplete != nil {
		{
			size, err := m.HOComplete.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintE2Sm(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}
func (m *RicControlOutcome_HOFailure) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *RicControlOutcome_HOFailure) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	if m.HOFailure != nil {
		{
			size, err := m.HOFailure.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintE2Sm(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x12
	}
	return len(dAtA) - i, nil
}
func encodeVarintE2Sm(dAtA []byte, offset int, v uint64) int {
	offset -= sovE2Sm(v)
	base := offset
	for v >= 1<<7 {
		dAtA[offset] = uint8(v&0x7f | 0x80)
		v >>= 7
		offset++
	}
	dAtA[offset] = uint8(v)
	return base
}
func (m *RicControlHeader) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.MessageType != 0 {
		n += 1 + sovE2Sm(uint64(m.MessageType))
	}
	return n
}

func (m *RicControlMessage) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.S != nil {
		n += m.S.Size()
	}
	return n
}

func (m *RicControlMessage_RRMConfig) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.RRMConfig != nil {
		l = m.RRMConfig.Size()
		n += 1 + l + sovE2Sm(uint64(l))
	}
	return n
}
func (m *RicControlMessage_HORequest) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.HORequest != nil {
		l = m.HORequest.Size()
		n += 1 + l + sovE2Sm(uint64(l))
	}
	return n
}
func (m *RicControlOutcome) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.S != nil {
		n += m.S.Size()
	}
	return n
}

func (m *RicControlOutcome_HOComplete) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.HOComplete != nil {
		l = m.HOComplete.Size()
		n += 1 + l + sovE2Sm(uint64(l))
	}
	return n
}
func (m *RicControlOutcome_HOFailure) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.HOFailure != nil {
		l = m.HOFailure.Size()
		n += 1 + l + sovE2Sm(uint64(l))
	}
	return n
}

func sovE2Sm(x uint64) (n int) {
	return (math_bits.Len64(x|1) + 6) / 7
}
func sozE2Sm(x uint64) (n int) {
	return sovE2Sm(uint64((x << 1) ^ uint64((int64(x) >> 63))))
}
func (m *RicControlHeader) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowE2Sm
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: RicControlHeader: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: RicControlHeader: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field MessageType", wireType)
			}
			m.MessageType = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowE2Sm
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.MessageType |= sb.MessageType(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipE2Sm(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthE2Sm
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthE2Sm
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *RicControlMessage) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowE2Sm
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: RicControlMessage: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: RicControlMessage: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field RRMConfig", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowE2Sm
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthE2Sm
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthE2Sm
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &sb.RRMConfig{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.S = &RicControlMessage_RRMConfig{v}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field HORequest", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowE2Sm
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthE2Sm
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthE2Sm
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &sb.HORequest{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.S = &RicControlMessage_HORequest{v}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipE2Sm(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthE2Sm
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthE2Sm
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *RicControlOutcome) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowE2Sm
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: RicControlOutcome: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: RicControlOutcome: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field HOComplete", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowE2Sm
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthE2Sm
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthE2Sm
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &sb.HOComplete{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.S = &RicControlOutcome_HOComplete{v}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field HOFailure", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowE2Sm
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthE2Sm
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthE2Sm
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &sb.HOFailure{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.S = &RicControlOutcome_HOFailure{v}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipE2Sm(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthE2Sm
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthE2Sm
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func skipE2Sm(dAtA []byte) (n int, err error) {
	l := len(dAtA)
	iNdEx := 0
	depth := 0
	for iNdEx < l {
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return 0, ErrIntOverflowE2Sm
			}
			if iNdEx >= l {
				return 0, io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		wireType := int(wire & 0x7)
		switch wireType {
		case 0:
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return 0, ErrIntOverflowE2Sm
				}
				if iNdEx >= l {
					return 0, io.ErrUnexpectedEOF
				}
				iNdEx++
				if dAtA[iNdEx-1] < 0x80 {
					break
				}
			}
		case 1:
			iNdEx += 8
		case 2:
			var length int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return 0, ErrIntOverflowE2Sm
				}
				if iNdEx >= l {
					return 0, io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				length |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if length < 0 {
				return 0, ErrInvalidLengthE2Sm
			}
			iNdEx += length
		case 3:
			depth++
		case 4:
			if depth == 0 {
				return 0, ErrUnexpectedEndOfGroupE2Sm
			}
			depth--
		case 5:
			iNdEx += 4
		default:
			return 0, fmt.Errorf("proto: illegal wireType %d", wireType)
		}
		if iNdEx < 0 {
			return 0, ErrInvalidLengthE2Sm
		}
		if depth == 0 {
			return iNdEx, nil
		}
	}
	return 0, io.ErrUnexpectedEOF
}

var (
	ErrInvalidLengthE2Sm        = fmt.Errorf("proto: negative length found during unmarshaling")
	ErrIntOverflowE2Sm          = fmt.Errorf("proto: integer overflow")
	ErrUnexpectedEndOfGroupE2Sm = fmt.Errorf("proto: unexpected end of group")
)
