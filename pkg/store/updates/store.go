// Code generated by onos-ric-generate. DO NOT EDIT.

package updates

import (
	"github.com/gogo/protobuf/proto"
	"github.com/onosproject/onos-lib-go/pkg/logging"
	e2ap "github.com/onosproject/onos-ric/api/sb/e2ap"
	"github.com/onosproject/onos-ric/api/store/message"
	"github.com/onosproject/onos-ric/pkg/config"
	messagestore "github.com/onosproject/onos-ric/pkg/store/message"
	timestore "github.com/onosproject/onos-ric/pkg/store/time"
)

var log = logging.GetLogger("store", "updates")

func NewDistributedStore(config config.Config, timeStore timestore.Store) (Store, error) {
	log.Info("Creating distributed store")
	messageStore, err := messagestore.NewDistributedStore("updates", config, "cache", timeStore)
	if err != nil {
		return nil, err
	}
	return &store{
		messageStore: messageStore,
	}, nil
}

func NewLocalStore(timeStore timestore.Store) (Store, error) {
	messageStore, err := messagestore.NewLocalStore("updates", timeStore)
	if err != nil {
		return nil, err
	}
	return &store{
		messageStore: messageStore,
	}, nil
}

var _ Store = &store{}

type store struct {
	messageStore messagestore.Store
}

func (s *store) Get(id ID, opts ...GetOption) (*e2ap.RicIndication, error) {
	messageOpts := make([]messagestore.GetOption, len(opts))
	for i, opt := range opts {
		messageOpts[i] = opt
	}
	entry, err := s.messageStore.Get(messagestore.PartitionKey(id.Partition), messagestore.ID(id.Key), messageOpts...)
	if err != nil {
		return nil, err
	} else if entry == nil {
		return nil, nil
	}
	return decode(entry)
}

func (s *store) Put(id ID, message *e2ap.RicIndication, opts ...PutOption) error {
	entry, err := encode(message)
	if err != nil {
		return err
	}
	return s.messageStore.Put(messagestore.PartitionKey(id.Partition), messagestore.ID(id.Key), entry)
}

func (s *store) Delete(id ID, opts ...DeleteOption) error {
	messageOpts := make([]messagestore.DeleteOption, len(opts))
	for i, opt := range opts {
		messageOpts[i] = opt
	}
	return s.messageStore.Delete(messagestore.PartitionKey(id.Partition), messagestore.ID(id.Key), messageOpts...)
}

func (s *store) List(ch chan<- e2ap.RicIndication) error {
	entryCh := make(chan message.MessageEntry)
	if err := s.messageStore.List(entryCh); err != nil {
		return err
	}
	go func() {
		defer close(ch)
		for entry := range entryCh {
			if message, err := decode(&entry); err == nil {
				ch <- *message
			}
		}
	}()
	return nil
}

func (s *store) Watch(ch chan<- Event, opts ...WatchOption) error {
	messageOpts := make([]messagestore.WatchOption, len(opts))
	for i, opt := range opts {
		messageOpts[i] = opt
	}

	watchCh := make(chan messagestore.Event)
	if err := s.messageStore.Watch(watchCh, messageOpts...); err != nil {
		return err
	}
	go func() {
		defer close(ch)
		for event := range watchCh {
			if message, err := decode(&event.Message); err == nil {
				event := Event{
					Type: EventType(event.Type),
					ID: ID{
						Partition: PartitionKey(event.Message.PartitionKey),
						Key:       Key(event.Message.Id),
					},
					Message: *message,
				}
				ch <- event
			}
		}
	}()
	return nil
}

func (s *store) Clear() error {
	return s.messageStore.Clear()
}

func (s *store) Close() error {
	return s.messageStore.Close()
}

func decode(message *message.MessageEntry) (*e2ap.RicIndication, error) {
	m := &e2ap.RicIndication{}
	if err := proto.Unmarshal(message.Bytes, m); err != nil {
		return nil, err
	}
	return m, nil
}

func encode(m *e2ap.RicIndication) (*message.MessageEntry, error) {
	bytes, err := proto.Marshal(m)
	if err != nil {
		return nil, err
	}
	return &message.MessageEntry{
		Bytes: bytes,
	}, nil
}

func toMessageRevision(revision Revision) messagestore.Revision {
	return messagestore.Revision{
		Term:      messagestore.Term(revision.Term),
		Timestamp: messagestore.Timestamp(revision.Timestamp),
	}
}
