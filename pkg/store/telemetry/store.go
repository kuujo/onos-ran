// Code generated by onos-ric-generate. DO NOT EDIT.

package telemetry

import (
	"github.com/gogo/protobuf/proto"
	"github.com/onosproject/onos-lib-go/pkg/logging"
	sb "github.com/onosproject/onos-ric/api/sb"
	"github.com/onosproject/onos-ric/api/store/message"
	"github.com/onosproject/onos-ric/pkg/config"
	messagestore "github.com/onosproject/onos-ric/pkg/store/message"
	timestore "github.com/onosproject/onos-ric/pkg/store/time"
)

var log = logging.GetLogger("store", "telemetry")

func NewDistributedStore(config config.Config, timeStore timestore.Store) (Store, error) {
	log.Info("Creating distributed store")
	messageStore, err := messagestore.NewDistributedStore("telemetry", config, "cache", timeStore)
	if err != nil {
		return nil, err
	}
	return &store{
		messageStore: messageStore,
	}, nil
}

func NewLocalStore(timeStore timestore.Store) (Store, error) {
	messageStore, err := messagestore.NewLocalStore("telemetry", timeStore)
	if err != nil {
		return nil, err
	}
	return &store{
		messageStore: messageStore,
	}, nil
}

var _ Store = &store{}

type store struct {
	messageStore messagestore.Store
}

func (s *store) Get(id ID, opts ...GetOption) (*sb.TelemetryMessage, error) {
	messageOpts := make([]messagestore.GetOption, len(opts))
	for i, opt := range opts {
		messageOpts[i] = opt
	}
	entry, err := s.messageStore.Get(messagestore.Key(id), messageOpts...)
	if err != nil {
		return nil, err
	} else if entry == nil {
		return nil, nil
	}
	return decode(entry)
}

func (s *store) Put(message *sb.TelemetryMessage) error {
	entry, err := encode(message)
	if err != nil {
		return err
	}
	return s.messageStore.Put(getKey(message), entry)
}

func (s *store) Delete(id ID, opts ...DeleteOption) error {
	messageOpts := make([]messagestore.DeleteOption, len(opts))
	for i, opt := range opts {
		messageOpts[i] = opt
	}
	return s.messageStore.Delete(messagestore.Key(id), messageOpts...)
}

func (s *store) List(ch chan<- sb.TelemetryMessage) error {
	entryCh := make(chan message.MessageEntry)
	if err := s.messageStore.List(entryCh); err != nil {
		return err
	}
	go func() {
		defer close(ch)
		for entry := range entryCh {
			if message, err := decode(&entry); err == nil {
				ch <- *message
			}
		}
	}()
	return nil
}

func (s *store) Watch(ch chan<- sb.TelemetryMessage, opts ...WatchOption) error {
	messageOpts := make([]messagestore.WatchOption, len(opts))
	for i, opt := range opts {
		messageOpts[i] = opt
	}

	watchCh := make(chan message.MessageEntry)
	if err := s.messageStore.Watch(watchCh, messageOpts...); err != nil {
		return err
	}
	go func() {
		defer close(ch)
		for entry := range watchCh {
			if message, err := decode(&entry); err == nil {
				ch <- *message
			}
		}
	}()
	return nil
}

func (s *store) Clear() error {
	return s.messageStore.Clear()
}

func (s *store) Close() error {
	return s.messageStore.Close()
}

func decode(message *message.MessageEntry) (*sb.TelemetryMessage, error) {
	m := &sb.TelemetryMessage{}
	if err := proto.Unmarshal(message.Bytes, m); err != nil {
		return nil, err
	}
	return m, nil
}

func encode(m *sb.TelemetryMessage) (*message.MessageEntry, error) {
	bytes, err := proto.Marshal(m)
	if err != nil {
		return nil, err
	}
	return &message.MessageEntry{
		Bytes: bytes,
	}, nil
}

func toMessageRevision(revision Revision) messagestore.Revision {
	return messagestore.Revision{
		Term:      messagestore.Term(revision.Term),
		Timestamp: messagestore.Timestamp(revision.Timestamp),
	}
}

func getKey(message *sb.TelemetryMessage) messagestore.Key {
	return messagestore.Key(message.GetID())
}
